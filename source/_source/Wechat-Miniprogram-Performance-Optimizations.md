title: 微信小程序性能优化浅谈
date: 2020-05-04
categories: 技术研究
tags: [微信小程序,uniapp,性能优化]
toc: true

---

## 小程序耗时分析



实际细分小程序渲染耗时，发现主要耗时是**渲染时长**，前端可以控制的部分为**同步脚本执行、数据请求**。

## 小程序同步脚本执行优化

实际打点发现，同步脚本中单行代码执行耗时较久的主要逻辑在**微信同步方法调用**，如 wx.setStorageSync、wx.getSystemInfoSync。由于之前的业务采用 wx storage 进行 cookie 存储，而业务中又有大量对 cookie 的访问，因此这部分耗时较久。

这里对 ks-mina-sdk-storage 库进行了优化，在内存中维护一份数据，在调用 get 方法时直接访问内存，在调用 set 时进行 diff 判断，有更新才进行系统调用。

本次优化在 50 分位约优化 200ms 耗时。

## 小程序数据请求优化

实际监控发现 reco 接口平均耗时较久，小程序在 photo 卡片做了 prefetch 数据预拉取和首页 reco 缓存：

1. 数据预拉取：微信提供的能力，用户点击卡片时直接拉取对应信息，当进入小程序执行代码阶段通过 api 传递数据；
2. 推荐缓存：每次新推荐接口到来后缓存最后 4 条视频，当用户下次进入时直接调取缓存进行展示，减少首屏等待时间； 

首页打开 50 分位约优化 400ms 耗时。

## 小程序渲染优化

每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下：

- **脚本转换**：小程序逻辑层调用宿主环境的 setData 方法。逻辑层执行 JSON.stringify 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过evaluateJavascript 执行脚本将数据传输到渲染层。
- **渲染队列**：渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。
- **Diff 与视图更新**：WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到UI视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。

### 额外的 setData

数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程。

1. **渲染无关元素触发 setData**：小程序目前使用 uniapp 框架，uniapp 有个致命的问题：由于DOM parser 部分不是运行时代码，它将所有 vue 的 data 和 computed value 都做成了界面 render 的 Watcher 所依赖的 Dep，因此这些数据有变化都会触发 setData。已跟 uniapp 开发者沟通，它们在下一个支持 vue3 的版本会解决这个问题，目前我们期望改写 vue-loader 来解决这个问题。
2. **未利用组件 props**：由于在项目中采用 Vuex 做状态管理，它将所有 state 数据转化为 computed value，因此 state 发生改变时会触发所有依赖组件的 setData；但是使用小程序自定义组件的 props 可以减少这些渲染。

### 页面首次渲染 DOM 节点数过多

这一点在发现有明显提升后，跟跟微信官方沟通确认过原理：

1. 页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。
2. 单个组件内节点数量约多，在每次重新渲染时 diff 耗时就越长。

采取的主要策略：

首页非主要模块的延迟渲染

中转页面减少渲染

作为中转页时的首页只渲染骨架屏

以上两个优化在 50 分位约优化 1600ms 耗时。 

## 小程序主包体积优化

1. 移除本地图片至 CDN；
2. 优化依赖库体积，选用更精简的依赖库；
3. 主包拆分，业务分包梳理；
4. 使用 Tree-shaking；

主包体积从 1200k → 800k（随业务迭代又恢复到 1100k），但对 fmp 基本没影响，仅对脚本下载时长有微弱影响。

（一顿操作猛如虎，一看性能还倒数）

总结：减少首屏 DOM 数量、合理拆分组件是目前最有效的优化方式。