<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>malcolm-blog</title>
  <subtitle>膜法师学徒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://malcolmyu.github.io/"/>
  <updated>2019-10-07T11:25:49.448Z</updated>
  <id>http://malcolmyu.github.io/</id>
  
  <author>
    <name>malcolm yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《智能商业》读书杂感</title>
    <link href="http://malcolmyu.github.io/2019/07/24/Notes-of-Business-Intelligence/"/>
    <id>http://malcolmyu.github.io/2019/07/24/Notes-of-Business-Intelligence/</id>
    <published>2019-07-23T16:00:00.000Z</published>
    <updated>2019-10-07T11:25:49.448Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>智能商业的作者是阿里巴巴的曾鸣教授，可以看做是作者执鞭阿里巴巴十年的经验总结。在提笔写总结之前，我经常会想，读这样的书有什么用呢？因为自己的格局没有达到，读这样的总结其实很难理解作者的各中意昧，即便是写了笔记，体会必然也十分肤浅。后来便觉得没必须要考虑这些，这种类型的书就先囫囵吞枣，以后再反复咀嚼，真正明白之时，感触必然更加深刻。</p>
<p>不过，吞归吞，对于这种通识类的书应当整理出思维脉络，毕竟<a href="https://www.bilibili.com/video/av33980096" target="_blank" rel="external">知识是一个网</a>，找到其中关键节点才能理解整个网络。</p>
<p>书里共有六章，按照书作者的自述，实际上 2013 年就已经完成了初稿，但自觉没有统一框架，又在剩下的几年里反复更迭，补充案例，才写成了现在这样的效果。书中第一章讲的是智能商业，这一章讲的是微观层面的问题，即当今商业是由什么细胞组成的；第二三章讲商业模式与战略，这其实是宏观层面的问题，讲这些年和今后商业的大趋势是什么。前三章思路清晰、格局宏大，应该是作者先前的定稿。第四章作者笔锋一转，写到了组织术上，聊了了如何构建一支队伍，更好的完成上位者的商业策略；第五章讲了讲具体案例，是对前三章知识理论的补充说明；第六章则谈了一些对未来的展望。后三章更像对前三章思路的补充，更像是作者后续的修改与补充。</p>
<p>本文准备简单聊一聊前三章，智能商业的组成与商业模式的范式转移。</p>
<p><img src="dna.svg" alt="双螺旋形成的数据黑洞"></p>
<p>作者在第一章一上来就提纲挈领地亮明了主旨：<strong>智能商业是网络协同+数据智能的双螺旋构成</strong>。抛去这两个晦涩的名词不看，我们不如先看看作者在数据黑洞这里提出的灵魂四问：</p>
<blockquote>
<p>在智能商业的时代，想要让自己的企业获得成功，首先要问自己4个问题： </p>
<ol>
<li>第一个问题，我的企业是否能最大限度地实现<strong>网络化</strong>？</li>
<li>第二个问题，我的企业能否尽可能地引入<strong>机器的学习</strong>效应？ </li>
<li>第三个问题，我的企业能不能在网络扩张的过程中，尽可能地用<strong>机器决策</strong>取代人工决策？ </li>
<li>第四个问题，我的企业能否让自己收集的数据与更多不同类型的数据产生交换？ </li>
</ol>
<p>这4个问题，每解决一个，你就离成功更近一步。</p>
<p>– P103 1.06 黑洞效应</p>
</blockquote>
<p>先来说说第一个问题，企业的网络化。作者在书里撂下一句狠话：</p>
<blockquote>
<p>商业最重要的就是结网。</p>
</blockquote>
<p>这里的网，其实有两层含义：</p>
<p>第一层讲的是真真切切的<strong>互联网</strong>：目前很多小企业或者处在点模式、线模式的经营范式，如果不把自己置身于网络之上，很难扩大规模，找到有效需求；更加无法进行数据在网络上的积累，向前再走一步。</p>
<p>第二层讲的则是<strong>网络协同效应</strong>：作者认为为了精准的找寻有效需求，未来的商业模式必定是 C2B 的模式，指通过客户喜好确定需求，影响商家的决策。然而这一步不成骤成，需要有一个过度模式：S2B2C，也就是所谓的没有中间商赚差价，我就是最大的中间商。这里的 S 本身就是一张大网，它网罗了供应商、网罗了客户，通过数据对二者赋能。滴滴、大搜车、土巴兔等本质上都是在构建这个 S。   </p>
<p>个人感觉『网』在作者的语境里，成了一种船新的思维模式，这套理论可以解释很多东西：例如后续作者聊到『网红』，网红本身就是将消费者从一个个零散的群体凝聚成网络的一个工具，它能够一定程度地分担 S 的作用，辅助供应链更好的决策，因此本身具有很高的商业价值。</p>
<p>说了这么多，对于小的 B 来说，最最重要的还是接入互联网，不然在新型商业模式的碾压之下无路可走；对于个人来说，进入大中台、找到网络赋能最核心的地方，才能紧跟浪潮。</p>
<p>然后看看二三问：机器学习与决策。这里其实讲的双螺旋的第二条旋：数据智能。作为一个前端工程师，我只想聊一聊数据化，智能的事情可以交给算法的老哥来做。作者在书里讲：</p>
<blockquote>
<p>『数据化』本质上是将一种现象转变为可量化形式的过程。</p>
</blockquote>
<p>提出<a href="https://zh.wikipedia.org/wiki/全面品质管理" target="_blank" rel="external">全面质量管理</a>的<a href="https://zh.wikipedia.org/wiki/愛德華茲·戴明" target="_blank" rel="external">爱德华兹·戴明</a>（彼得·德鲁克似乎也讲过）讲：</p>
<blockquote>
<p>You can’t manage what you can’t measure.</p>
</blockquote>
<p>实际上『数据化』就是如何测量的一个重要手段，这里其实对用户侧的工程师提出了一定的要求：尽可能的记录全量数据、能够进行一定程度的分析、形成反馈闭环。</p>
<p><img src="BI.svg" alt="数据智能结构"></p>
<p>如果你对具体怎么做毫无头绪，作者其实也贴心地给出了开始行动方案：</p>
<blockquote>
<p>有效的数据初始化是大数据创造价值至关重要的第一步。</p>
</blockquote>
<p>先进行埋点，把所有数据进行统计，事后再慢慢调整分析，让数据驱动决策。</p>
<p>最后看看第四问，实际上这里讲的是如何形成<strong>黑洞效应</strong>。作者认为构建了网络协同和数据智能的商业体能够依靠网络进行自我传播，因为数据本身会产生压强，而且传播成本极低（新时代、高维度的造纸术、印刷术），因此这个网络会无限繁殖扩张。这一点作为一个工程师而不是企业主，只能先畅想一下，有点超纲。                                                                                                                                                                                  </p>
<p>最后总结一下：合上本书，发现其实所有内容归根结底就是一句话：<strong>如何创造有效需求</strong>。</p>
<p>按照马克思的理论，大资本倾向于生产过剩，工人们却无法产生需求，最终正反馈循环崩塌。这个简单的模型只是说明了总体趋势，但实际上还有很多细节可以进行调整续命：如书里的利用数据智能进行有效需求挖掘，尽可能的填补实业无法发掘的需求，无疑是后面的资本主义商业的续命发展方向。</p>
<p>不过对于普通人来说，知道两点就已足够：</p>
<ol>
<li>奔赴大中台建设，找到大 S 企业，在未来的一段时间内『拥有数据智能和网络协同大型中间商』是发展方向；</li>
<li>学习机器学习、数据分析的知识。还要多学数学，『学数学买菜用不到』已经成为历史，未来的小商家可能都要通过大 S 来买菜（比如美菜网之类），大 S 里几乎全是帮你公式计算怎么买菜合理的老铁们，你当然用不到，但是你得加钱。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;智能商业的作者是阿里巴巴的曾鸣教授，可以看做是作者执鞭阿里巴巴十年的经验总结
    
    </summary>
    
      <category term="读书笔记" scheme="http://malcolmyu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="智能商业" scheme="http://malcolmyu.github.io/tags/%E6%99%BA%E8%83%BD%E5%95%86%E4%B8%9A/"/>
    
      <category term="读书笔记" scheme="http://malcolmyu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>V8 增量 GC 之三色标记</title>
    <link href="http://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/"/>
    <id>http://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2019-10-07T07:58:47.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>因为要做组内分享，最近看了一下<a href="https://book.douban.com/subject/26821357/" target="_blank" rel="external">《垃圾回收算法与实现》</a>，发现其实垃圾回收的算法基调基本上世纪 60 年代就已经提出来了，后世的框架只是在给这些框架做组合和修补的工作。抛掉老生常谈的分代假设不谈，V8 官博今年新发了一篇<a href="https://v8.dev/blog/trash-talk#incremental" target="_blank" rel="external">博文</a>介绍 V8 GC 新进展，讲到<a href="https://v8.js.cn/blog/concurrent-marking/" target="_blank" rel="external">增量回收</a>的话题。本以为增量 GC 是什么新鲜东西，实际上早在 1975 年的一篇<a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html" target="_blank" rel="external">论文</a>中，大宗师 Dijkstra 就已经提出了这个问题的解决方案——<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking" target="_blank" rel="external">三色标记算法</a>。</p>
<a id="more"></a>
<p>令我疑惑的是，分代假设、清道夫算法跟传统的 Mark-Sweep 算法，都是符合逻辑容易理解的；但到了三色标记这儿，好多资料都是语焉不详的：大家都尽力在描述这个算法的实现（其实也并不复杂），有的也给出了动图（后来发现是抄的维基百科），但并没有博文真正解答这个问题：为什么不能直接用双色标记，而要用三色标记？</p>
<p>为了避免这个知识成为需要靠死记硬背才能记住的知识孤岛，我翻了一下大法师的论文原文，总算有了些头绪。</p>
<h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>我们首先先迅速而简单地介绍一下，到底什么是垃圾回收？其实顾名思义，主要是两点：垃圾、回收。</p>
<p>然后基于这两点有个 What/How/When，基本就把事儿讲明白了，翻译成官方术语就是：</p>
<ul>
<li>什么是垃圾？如何找到垃圾？何时找垃圾？</li>
<li>什么是回收？怎么回收？何时回收？</li>
</ul>
<p>对于所有的垃圾回收而言，垃圾其实都是指已经没用的内存区域，回收就是指让这些区域可以被新的有用数据覆盖；对于怎么回收而言，也基本就是 Sweep 和 Compact 这两种策略，回收的时机也都是找完了就操作；但是在找垃圾（后面就称之为标记）的 How/When 这里，传统和增量就产生了区别：</p>
<p>对于传统的算法而言，垃圾回收是『<strong>全暂停</strong>式』（Stop-The-World，后面简称 STW）的，当程序（专业术语称 mutator，指能改变这个内存区域是否被程序引用的东西，比如程序本身。顺带一提，这个词儿也是 Dijkstra 琢磨出来的）执行，GC 等着；特定时机时（比如内存满了）GC 执行，mutator 等着。因此它的如何找和何时找都比较简单：内存满，STW 开始；而找垃圾就是一种图的遍历，从 Root 出发，对所有能访问的节点进行标记，访问不到的就是垃圾。</p>
<p><img src="https://v8.js.cn/_img/concurrent-marking/03.svg" alt></p>
<p>采取 STW 这样凶残的策略，主要还是防止 mutator 在 GC 的时候捣乱——这跟你用扫地机器人的时候把狗关屋子的道理是一样的；而增量标记，就等于赶着狗扫地，是一个跟 mutator 斗智斗勇的过程。</p>
<h2 id="增量回收的困境"><a href="#增量回收的困境" class="headerlink" title="增量回收的困境"></a>增量回收的困境</h2><p>对于增量回收而言，主要存在两个问题：第一个是需要暂停重启，第二个就是调皮的 mutator。</p>
<h3 id="暂停重启"><a href="#暂停重启" class="headerlink" title="暂停重启"></a>暂停重启</h3><p><img src="https://v8.dev/_img/trash-talk/06.svg" alt="增量回收"></p>
<p>因为增量回收是<strong>并发</strong>的（concurrent），因此它的过程像上图一样（可以想象一下 CPU 的时间片轮转），这就意味着 GC 可能被随时暂停、重启，因此暂停时需要保存当时的扫描结果，等下一波 GC 来之后还能继续启动。而双色标记实际上<strong>仅仅是对扫描结果的描述</strong>：非黑即白，但忽略了对<strong>扫描进行状态的描述</strong>：这个点的子节点扫完了没有？假如我上次停在这样一个图上，重新启动的时候我就不仅要问：到底 A、B 点要不要扫子节点？</p>
<p><img src="black-white.jpg" width="380"></p>
<p>为了处理这种情况，Dijkstra 引入了另外一种颜色：<strong>灰色</strong>，它表示<strong>这个节点被 Root 引用到，但子节点我还没处理</strong>；而黑色的意思就变为：这个节点被 Root 引用到，而且子节点都已经标记完成。这样在恢复扫码时，只需要处理灰色节点即可。</p>
<p><img src="https://v8.js.cn/_img/concurrent-marking/02.svg" alt></p>
<p>引入灰色标记还有一个好处，就是当图中没有灰色节点时，便是整个图标记完成之时，就可以进行清理工作了。</p>
<h3 id="调皮的-mutator"><a href="#调皮的-mutator" class="headerlink" title="调皮的 mutator"></a>调皮的 mutator</h3><p>解决了三色的问题，就可以增量回收了么？其实没有这么简单。我们可以想象一下，什么是失败的垃圾回收？无非就是两点：</p>
<ol>
<li>把有用的东西扔了；</li>
<li>把没用的东西留着；</li>
</ol>
<p>其实只要有手段，没用的垃圾还是可以忍它留几轮；但是有用的被干掉是无法忍受的：我刚声明了一个变量你就告诉我 Reference Error，我 fuuuuu 佛慈悲。</p>
<p>对于传统的 STW 而言，通过根节点标记引用，能力立刻区分当前状态下的有用和没用，再做操作的时候便游刃有余；但是对于增量回收而言就不同了，Dijkstra 在论文里举了一个很顽皮的 mutator：</p>
<ol>
<li>三个节点 ABC，C 在 AB 之间反复横跳，一会儿只有 A 指向 C，一会儿只有 B 指向 C；</li>
<li>开始扫 A 时，C 的爸爸是 B，扫完了 A 节点是黑的， C 是白的；</li>
<li>开始扫 B 时，C 的爸爸是 A，扫完了 B 没有子节点，B 节点是黑的，C 还是白的；</li>
<li>由于 A 节点已经标黑，无法扫描其子节点，只好继续向后扫描；</li>
<li>一顿蛇皮操作之后，C 被当成孤儿干掉了，C 的爸爸们留下了无奈的泪水。</li>
</ol>
<p><img src="marking-miss.jpg" alt="标记遗漏"></p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>刚才的案例其实就是说了一个问题：在 mutator 瞎操作的情况下，很有可能将已经标记为扫描完事儿的节点（黑色节点）续上一个当时还未被扫描的白色节点。而一旦这个白色节点后续又被其他已经扫描过的节点引用到，也没有什么机制能够再收集它了。</p>
<p>在思考完这个案例之后，Dijkstra 提出了一个要求：不能让黑色节点指向白色节点！每当发生引用变化时，需要立刻对被引用节点进行着色：即白的立刻染灰，灰的和黑的不变。</p>
<p>比如上面 C 的例子，当 C 的父节点发送变化时，一定会出现类似这样的代码：<code>A.C = C</code>，发生之后，立刻给 C 节点着色并推入灰色栈，这样就解决了不小心清理掉有用节点的问题。</p>
<p><img src="write-barrier.jpg" alt="写屏障"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，三色标记主要是为了解决增量标记中传统双色标记过程无法分片的问题，有了三色标记，传统的双色标记便可以暂停重启，因此就可以划分成小段，变成跟 mutator 并发的方式来运行；写屏障则是用来解决并发中 mutator 变化，导致有用内存被清理的问题。三色标记只是垃圾回收众多技术方案之中的一个小插曲，其他如分代假设、清道夫算法等都有其精妙之处，可以深入研究。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://yq.aliyun.com/articles/592878" target="_blank" rel="external">朴神雄文 V8 GC Log</a></li>
<li><a href="https://book.douban.com/subject/26821357/" target="_blank" rel="external">垃圾回收的算法与实现</a></li>
<li><a href="http://wiki.luajit.org/New-Garbage-Collector" target="_blank" rel="external">Lua JIT 文档</a>：有趣的是，由于 Lua 在 5.0 之前一直使用 STW 的双色标记，因此只有它在文档里简单描述了一下三色标记与双色标记的区别，甚至还提出了四色标记算法；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为要做组内分享，最近看了一下&lt;a href=&quot;https://book.douban.com/subject/26821357/&quot;&gt;《垃圾回收算法与实现》&lt;/a&gt;，发现其实垃圾回收的算法基调基本上世纪 60 年代就已经提出来了，后世的框架只是在给这些框架做组合和修补的工作。抛掉老生常谈的分代假设不谈，V8 官博今年新发了一篇&lt;a href=&quot;https://v8.dev/blog/trash-talk#incremental&quot;&gt;博文&lt;/a&gt;介绍 V8 GC 新进展，讲到&lt;a href=&quot;https://v8.js.cn/blog/concurrent-marking/&quot;&gt;增量回收&lt;/a&gt;的话题。本以为增量 GC 是什么新鲜东西，实际上早在 1975 年的一篇&lt;a href=&quot;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html&quot;&gt;论文&lt;/a&gt;中，大宗师 Dijkstra 就已经提出了这个问题的解决方案——&lt;a href=&quot;https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking&quot;&gt;三色标记算法&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="V8" scheme="http://malcolmyu.github.io/tags/V8/"/>
    
      <category term="GC" scheme="http://malcolmyu.github.io/tags/GC/"/>
    
      <category term="Tri-Color Marking" scheme="http://malcolmyu.github.io/tags/Tri-Color-Marking/"/>
    
  </entry>
  
  <entry>
    <title>MobX 源码探究之一 —— 核心概念</title>
    <link href="http://malcolmyu.github.io/2018/09/09/Core-Concepts-of-Mobx/"/>
    <id>http://malcolmyu.github.io/2018/09/09/Core-Concepts-of-Mobx/</id>
    <published>2018-09-08T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><strong>Anything that can be derived from the application state, should be derived. Automatically.</strong></p>
<p>任何可以从应用状态中推导的东西，都应该被<strong>自动地</strong>推导出来。</p>
</blockquote>
<p>上面两句话是 MobX 中文官网关于 MobX 的总结，初读起来觉得逼格慢慢，但毫无诚意——因为这样上升到哲学高度的话对于你对它工作原理的理解实际上是毫无帮助的，甚至于你用了框架若干年之后，依然无法理解这其中的含义。但是，哲学层次的总结总是需要在读完代码之后再细细品味的，就像老话说的，『当你千辛万苦读完代码爬上山顶的时候，框架作者装逼的哲学总结已经在此等候多时了』。</p>
<a id="more"></a>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>我们今天先抛开这段话，简单的看一下 MobX 基本的工作原理和几个核心的概念。MobX 是一个接地气的数据流框架，它给命令式编程和响应式编程搭建了一座桥梁，让前端小白们能够通过简单的赋值语句驱动 React 视图的渲染。这对于个把月也搞不明白 Redux 是个啥，或者即使搞明白也要天天撸模板代码的各位前端同僚们来说，节省了大把时间，下班回家的时间又可以提前几分钟<del>（不存在的）</del>。</p>
<p>我们来看一个最简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 封装可观测值</span></span><br><span class="line"><span class="keyword">const</span> store = observable(&#123; a: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 依赖收集，打印 1</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 推导，触发 derivation 的重新执行，打印 2</span></span><br><span class="line">store.a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子就是一个最基础的 MobX 功能，它明显的分为三个步骤：</p>
<ol>
<li><p><strong>封装可观测值</strong>，对其他 MVVM 框架有了解的同学们应该能理解这个过程，这一步的操作的目的是：把一个单纯对象，封装成一个巨复杂的对象。（如上例中的 <code>{ a: 1 }</code> 就变成了下图的样子）</p>
<p><img src="https://ww1.sinaimg.cn/large/7921624bly1fv3l54n33tj21bs06cabh.jpg" alt="面目全非的 Plain Object"></p>
<p>这个巨复杂的对象它的学名叫做<strong>可观测值（Observable）</strong>，是 MobX 里第一个重要的概念。</p>
</li>
<li><p><strong>依赖收集</strong>，第二步使用 autorun 包裹一个回调的操作，学名叫做依赖收集。这里这个打印 a 的回调，MobX 叫它<strong>衍生（Derivation）</strong>，这是 MobX 里第二个重要的概念。但实际上，这里在运行时还暗含了一个步骤，就是<strong>封装衍生</strong>，衍生本身也是一个巨复杂的对象，在运行 <code>autorun</code> 的时候，会构造出这个对象。</p>
</li>
<li><p><strong>推导</strong>，第三步给可观测值赋值的行为会触发推导，这是展示 MobX 膜法实力的一步，前面几部的铺垫实际上也是为了这一步而做准备。这里仅仅使用了一行赋值语句，便可以驱动第二步中的衍生函数自动执行，这就是文档里提到的桥接『命令式编程』与『响应式编程』。</p>
</li>
</ol>
<p>上面的三个步骤还引出了 MobX 的两个核心概念：<strong>可观测值</strong>和<strong>衍生</strong>。MobX 的其他概念和行为要么是基于这两个概念实现的，要么是围绕着这两个概念展开的。</p>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>说了这么多是不是懵逼了？别急，这几段如同开头的哲学语录一样，主要是切个题，回过头我们再来看这些概念。现在先看下 MobX 是怎么做到自动执行代码的？</p>
<p>大家应该都对前端里经常用到的一个设计模式『观察者模式』有一定的了解，DOM 的事件绑定本身就有这种模式，而且很多组件库里大多都实现了这种 <code>EventEimitter</code> 的效果，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> em = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调，对应上面的第二步『依赖收集』</span></span><br><span class="line">em.on(<span class="string">'event-a'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'aaa'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发回调，对应上面的第三部『推导』</span></span><br><span class="line">em.emit(<span class="string">'event-a'</span>); <span class="comment">// 执行之前注册的回调，输出 aaa</span></span><br></pre></td></tr></table></figure>
<p>其实细细看来，这个自动触发的效果，跟上面的 <code>autorun</code> 也有几分类似嘛！<code>autorun</code> 其实就是这里 <code>on</code> 方法的效果；对 <code>store.a</code> 的赋值，实际上就是 <code>emit</code> 的效果。实际上，除却 <code>computed</code> 计算属性，普通的自动执行或者叫<strong>自动推导的原理，实际上跟 EventEmitter 是非常相似的</strong>。</p>
<p>他们的区别仅仅在于：<strong>回调注册和触发的手段，是隐式而非显式的</strong>。为了这一 magic 的效果，各路 MVVM 框架做了好多工作，才让代码写起来如此的令人愉悦。</p>
<p>我们先看一下 MobX 里『触发回调』的实现手段：仅仅是一行简单的赋值语句：<code>store.a = 2</code>。这行我们天天都会写到的赋值，背后实际上干了许许多多的工作。我们思考一下，能够让一行赋值语句，能够执行其他回调的方式有什么办法呢？</p>
<p>是的，就是 <code>Object.definePorperty</code>（或者 Proxy），具体参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">这里</a>。因此我们可以简单的理解 MobX 在运行过程中，进行了这样的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> em = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(store, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function() &#123;</span><br><span class="line">    em.emit(<span class="string">'event'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.a = <span class="number">2</span>; <span class="comment">// 执行 set 方法，触发 event-a</span></span><br></pre></td></tr></table></figure>
<p>好了，推导的手段有了，那么如何确定在 emit 的时候应该触发哪个方法呢？或者说 MobX 的回调是什么时候注册的呢？其实核心就在这个 <code>autorun</code> 方法之中。</p>
<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>我们看一下 <code>autorun</code> 的功能，它实际上是要把回调中运行的所有可观测值收集起来，等到其中一个值发生变动时，重新运行该回调。有心的同学可能会发现，上面的例子中在第二步有输出结果，也就是<strong>在运行 <code>autorun</code> 方法的时候，内部的回调是会执行的</strong>。如图：</p>
<p><img src="https://ww1.sinaimg.cn/large/7921624bly1fvjlw2yjqfj215y09ejt3.jpg" alt="autorun 的自动执行"></p>
<p>这里的执行实际上就是关键：我们上文中提到，MobX 在赋值时，通过 <code>set</code> 成功的做了触发回调的行为，那么与 <code>set</code> 相对应的就是 <code>get</code> 方法。在代码执行的时候，涉及到取值操作，就会导致  <code>get</code> 方法的触发，MobX 就是在这里进行了依赖收集，或者叫回调注册的的操作。</p>
<p>我们把上面的代码再扩展一下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> em = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(store, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    em.on(<span class="string">'event'</span>, <span class="comment">/* 这里的回调怎么写呢？ */</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function() &#123;</span><br><span class="line">    em.emit(<span class="string">'event'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.a = <span class="number">2</span>; <span class="comment">// 执行 set 方法，触发 event-a</span></span><br></pre></td></tr></table></figure>
<p>那么问题来了，我们知道 MobX 是在 get 中进行的依赖收集，那它是如何知道对应的回调是哪一个呢？这里其实就是一个问题，如何在函数运行时获得当前正在运行的函数？</p>
<p>有人可能会立刻提到一个手段：<code>arguments.callee</code>。首先，这个方法并不推荐使用，而且如果遇到下面的情况会引发问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// other code...</span></span><br><span class="line">  <span class="keyword">const</span> funcInAutorun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(store.a);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  funcInAutorun();</span><br><span class="line">  <span class="comment">// other code...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样会仅执行 funcInAutorun，而不会执行 autorun 的其他代码</span></span><br><span class="line">store.a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>那么 MobX 究竟是怎么操作的呢？其实很简单，MobX 用了一个全局变量。</p>
<p>MobX 在 <code>autorun</code> 的回调执行前，开了一个全局变量叫做 <code>pendingDerivation</code>，并把当前的回调赋值给它，当这个方法执行完成后再把这个变量置空（或者置回上层推导函数）。由于 <code>get</code> 方法也是同步执行，因此在执行时可以找到当前的 <code>pendingDerivation</code>，把它当做要收集的回调。</p>
<p>我们修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> em = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="comment">// 简单起见就叫 pending 吧</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> autorun = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  pending = fn;</span><br><span class="line">  fn();</span><br><span class="line">  pending = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(store, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="comment">// 直接注册当前执行的推导函数</span></span><br><span class="line">    em.on(<span class="string">'event'</span>, pending);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function() &#123;</span><br><span class="line">    em.emit(<span class="string">'event'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 get 方法，进行依赖收集</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.a));</span><br><span class="line"></span><br><span class="line">store.a = <span class="number">2</span>; <span class="comment">// 执行 set 方法，触发 event</span></span><br></pre></td></tr></table></figure>
<p>其实在同步情况下，使用全局变量标记运行情况可以解决很多问题。</p>
<h2 id="封装可观测值"><a href="#封装可观测值" class="headerlink" title="封装可观测值"></a>封装可观测值</h2><p>实际上，做完这一步，就把自动推导的核心工作搞定了，不过我们上面的代码还有个问题没有考虑：没有对 a 本身的值进行管理，现在赋值和取值都只能触发副作用，而不能得到正确的值，这有点不太行。</p>
<p>好吧，因此我们需要处理一下上面简陋的 <code>defineProperty</code> 工作，也就是 MobX 里面的 <code>observable</code> 方法。</p>
<p>根据上面的探索，我们得出 <code>observable</code> 方法需要进行两步的工作：</p>
<ol>
<li>对本身的值进行存储；</li>
<li>进行依赖收集和触发的封装；</li>
</ol>
<p>我们定义一个 <code>_data</code> 私有属性，来存放它原本的值，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EM = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="keyword">const</span> em = <span class="keyword">new</span> EM();</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----框架代码-----</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> autorun = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  pending = fn;</span><br><span class="line">  fn();</span><br><span class="line">  pending = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="function">(<span class="params">o</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个 _data 要是不可枚举的，放在被再次封装上 get、set 方法</span></span><br><span class="line">  <span class="comment">// 它仅用于进行值的存储</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o, <span class="string">'_data'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="built_in">Object</span>.assign(&#123;&#125;, o),</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 封装 get/set</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(o).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(o, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending) em.on(<span class="string">'event'</span>, pending);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function(v) &#123;</span><br><span class="line">        <span class="comment">// 一个简单的处理，值不变时不触发</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._data[key] !== v) &#123;</span><br><span class="line">          <span class="keyword">this</span>._data[key] = v;</span><br><span class="line">          em.emit(<span class="string">'event'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----业务代码-----</span></span><br><span class="line"><span class="keyword">const</span> store = observable(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 get 方法，进行依赖收集</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.a)); <span class="comment">// 成功工作执行 1</span></span><br><span class="line"></span><br><span class="line">store.a = <span class="number">2</span>; <span class="comment">// 成功工作执行 2</span></span><br></pre></td></tr></table></figure>
<p>经过这样一通处理，我们用不到 50 行代码实现了一个简单的，只有一层深度可观测值，且推导函数不能嵌套的微型 MobX<del>（缺点好多啊好像没什么卵用）</del>。不过这次的代码编写只是想跟大家分享一下 MobX 的最最基本的原理，这时候我们再去回顾一下开篇的几个概念：</p>
<ol>
<li><strong>封装可观测值</strong>（box observable values），把一个单纯对象，封装成一个巨复杂的对象。在我们代码里，这里处理了事件收集、触发和值本身，是最复杂的逻辑；</li>
<li><strong>依赖收集</strong>（tracking dependencies），依赖收集实际上是 <code>get</code> 里面做的工作，要注意的是 MobX 通过一个全局变量，完成了对当前正在运行的推导函数的收集；</li>
<li><strong>推导 </strong>(derive)，经过上面两步的操作，推导反而成了最容易的一步，只要触发回调就好，水到渠成。</li>
</ol>
<p>本文我们主要聊了聊 MobX 中或者说是 MVVM 框架中的几个核心概念，如果想阅读 MobX 源代码，希望参考我文末的文章，特别推荐 JSON 简时空的<a href="https://segmentfault.com/a/1190000013682735" target="_blank" rel="noopener">几篇博文</a>，起到了把代码翻译成人话的作用，对有志阅读代码的童鞋简直就是一盏指明灯。</p>
<p>下篇文章我会着重说下 MobX 作者最引以为豪的 <code>computed</code> 的实现，大多数自动推导的框架都没有在 <code>computed</code> 上进行像 MobX 这样的性能优化（同时回味一下作者那句哲学总结）。</p>
<hr>
<p><em>参考文章</em></p>
<ul>
<li><a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">MobX 中文文档</a> 至少先搞明白咋用吧</li>
<li><a href="https://github.com/sorrycc/blog/issues/3" target="_blank" rel="noopener">MobX 原理</a> dva 作者，云谦老哥写的，简单易懂</li>
<li><a href="https://segmentfault.com/a/1190000013682735" target="_blank" rel="noopener">用故事解读 MobX 源码系列</a> 这个系列非常好，跟读源码差不多，作者对很多细节有图文并茂的解释 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Anything that can be derived from the application state, should be derived. Automatically.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何可以从应用状态中推导的东西，都应该被&lt;strong&gt;自动地&lt;/strong&gt;推导出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面两句话是 MobX 中文官网关于 MobX 的总结，初读起来觉得逼格慢慢，但毫无诚意——因为这样上升到哲学高度的话对于你对它工作原理的理解实际上是毫无帮助的，甚至于你用了框架若干年之后，依然无法理解这其中的含义。但是，哲学层次的总结总是需要在读完代码之后再细细品味的，就像老话说的，『当你千辛万苦读完代码爬上山顶的时候，框架作者装逼的哲学总结已经在此等候多时了』。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://malcolmyu.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="MobX" scheme="http://malcolmyu.github.io/tags/MobX/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】终极响应式编程：深入探究 MobX</title>
    <link href="http://malcolmyu.github.io/2017/10/14/An-in-Depth-Explanation-of-MobX/"/>
    <id>http://malcolmyu.github.io/2017/10/14/An-in-Depth-Explanation-of-MobX/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.775Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="/2017/10/14/An-in-Depth-Explanation-of-MobX/title.jpg" title="mobx">
<p>鉴于广大人民群众的要求（并为了到时候能给我的孙子吹个 NB），我写了这篇 MobX 的内部工作原理。许多朋友震惊于 MobX 的性能和一致性，但请各位放心，这里没有什么黑科技！</p>
<a id="more"></a>
<p><a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank" rel="noopener">原文链接</a></p>
<p>首先让我们定义 MobX 里的一些核心概念：</p>
<ol>
<li><strong>可观测状态（Observable State）</strong>任何可以被变异（mutate）且可作为计算值来源的值都是状态。MobX 可以使大多数类型的值（基本类型、数组、类、对象等）甚至引用（以及循环引用）自动变成可观测的。</li>
<li><strong>计算值（Computed Values）</strong>任何可以通过使用这样一种函数计算的值都可称为计算值：该函数仅仅对其他的可观测值进行运算。小到字符串拼接，大到衍生出（derive）复杂对象的图形化和可视化。由于计算值本身是可观察的，因此可观测状态甚至可以衍生出完整的用户界面。计算值可能会延迟求值，或在对状态改变做出响应时求值。</li>
<li><strong>响应（Reactions）</strong> 响应与计算值有点相似，但计算值会产生一个新值，响应会产生一个副作用。响应是响应式编程与命令式编程之间的桥梁，如打印到控制台、进行网络请求、逐渐更新 React 组件树以更新 DOM 等。</li>
<li><strong>行为（Actions）</strong>行为是修改状态的主要手段，行为不是对状态变化做出的响应，而是更改可观测状态的来源，例如用户事件、传入的 web-socket 链接等。</li>
</ol>
<p><strong>计算值</strong>和<strong>响应</strong>在本文的其余部分都被称作<strong>衍生</strong>。说了这么多，可能听起来都有点太学术了，让我们举个栗子吧！在电子表格中，有值的单元格都是<strong>可观测状态</strong>；公式和图标是可从数据单元格和其他公式推导出的<strong>计算值</strong>；在屏幕上绘制数据单元格、公式的输出结果就是一个<strong>响应</strong>；对数据单元格或公式的修改就是一次<strong>行为</strong>。</p>
<p>总之，这里有一个使用了 MobX 和 React 的小例子，展示了上面全部的四种概念：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @observable firstName = <span class="string">"Michel"</span>;</span><br><span class="line">  @observable lastName = <span class="string">"Weststrate"</span>;</span><br><span class="line">  @observable nickName;</span><br><span class="line">  </span><br><span class="line">  @computed <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> michel = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应：当用户信息改变时进行打印</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    person.nickName ? person.nickName : person.fullName</span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 组件作为一个观测状态的例子</span></span><br><span class="line"><span class="keyword">const</span> ProfileView = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.person.nickName)</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.nickName&#125;&lt;/div&gt;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.fullName&#125;&lt;/div&gt;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> michel.nickName = <span class="string">"mweststrate"</span>, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">React.render(&lt;ProfileView person=&#123;michel&#125; /&gt;), document.body);</span><br></pre></td></tr></table></figure>
  <figcaption>代码 1：可观测状态、计算值、可响应的 Reactjs 组件和一些行为</figcaption>

<p><a href="https://jsfiddle.net/mweststrate/049r6jox/" target="_blank" rel="noopener">在线运行该实例</a></p>
<p>我们可以根据上面的代码绘制一个依赖树，直观看来如下所示：</p>
<p><img src="figure1.png" alt="图 1"></p>
  <figcaption>图 1：ProfileView 组件的依赖树，FullName 处在响应模式，主动观察 firstName 和  lastName</figcaption>


<p>这个应用的<strong>状态</strong>会被蓝色的可观测属性<strong>捕获</strong>，绿色的<strong>计算值</strong> fullName 可从状态里通过观测 firstName 和 lastName 自动被<strong>衍生（derived）</strong>。类似地，ProfileView 的渲染可以从 nickName 和 fullName 中衍生。ProfileVIew 将会响应状态的变化并产生一个副作用：更新 React 组件树。</p>
<p>MobX 最低程度地定义依赖树。例如，一旦被渲染的人拥有一个 nickName，渲染将不再受到 fullName、firstName 或 lastName 输出值的影响（见代码 1）。所有这些值的观测关系可被清除，MobX 会响应地自动简化依赖树：</p>
<p><img src="figure2.png" alt="图2"></p>
  <figcaption>图 2：在用户拥有 nickname 时 ProfileView 组件依赖树。与图 1 相反，fullName 现在处于惰性模式（lazy mode）且不观测 firstName 和 lastName</figcaption>

<p>MobX 将始终尝试减少产生一致状态所需要的计算数。在本文的余下内容，我将介绍几个用于实现这一目标的几个策略。但在深入了解计算值和响应与状态保持同步的黑魔法之前，让我们先描述下 MobX 背后的原理：</p>
<h3 id="对状态改变做出响应，总是比直接处理状态改变要好"><a href="#对状态改变做出响应，总是比直接处理状态改变要好" class="headerlink" title="对状态改变做出响应，总是比直接处理状态改变要好"></a>对状态改变做出响应，总是比直接处理状态改变要好</h3><blockquote>
<p>自动更新应用的状态是一个反模式，数据应该被衍生。</p>
</blockquote>
<p>应用程序触发的用来响应状态变化的任何命令式行为通常都会创建或改变某些值。换句话说，大多数行为都会管理一个<a href="https://medium.com/@mweststrate/pure-rendering-in-the-light-of-time-and-state-4b537d8d40b1" target="_blank" rel="noopener">本地缓存</a>。触发用户界面的更新？更新级联的值？通知后端？这些通常被认为是潜在的缓存失效。为了确保这些缓存同步，你需要订阅（subscribe）将来的状态更改，这会导致行为再次被触发。</p>
<p>但是使用订阅（或者叫游标、镜头、选择器、连接器等）都有一个根本的问题：随着应用程序复杂度的加深，你在管理这些订阅时可能会出现错误：要么出现<strong>超额订阅</strong>（指订阅了一个不再在 component 中使用的值或 store），要么出现<strong>失效订阅</strong>（指忘记监听更新导致一些不易察觉的数据过期的 bug）。</p>
<blockquote>
<p>换句话说，当人为管理订阅时，你的应用最终会出现不一致性。</p>
</blockquote>
<p><img src="figure3.png" alt="图 3"></p>
  <figcaption>图 3：Twitter 页面在更新个人信息时产生的不一致性。推文中的小图片展示了一个过时的用户名和头像</figcaption>

<p>上面的图片是一个展示 Twitter UI 不一致的很好的例子，我在 <a href="https://www.youtube.com/watch?v=FEwLwiizlk0" target="_blank" rel="noopener">Reactive 2015 talk</a> 中解释过，只有两种情况可能会导致这一点：要么是推文的模块没有订阅对应用户信息的改变，要么是数据正常且推文的作者甚至不与当前登录的用户关联，尽管事实上两者都尝试描述同一人的相同属性。</p>
<p>像 Flux 那种类型的 store 粗粒度的订阅方式很容易触发超额订阅。在使用 React 的时候，你可以简单的通过打印<a href="https://reactjs.org/docs/perf.html#perf.printwastedmeasurements" target="_blank" rel="noopener">浪费的渲染</a>以很快的检测到你的组件是否超额订阅。MobX 会把<a href="https://www.mendix.com/blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" target="_blank" rel="noopener">浪费渲染的次数降到 0</a>。这个理念简单却违反直觉：更多的订阅导致更少的重复计算。MobX 帮你管理成千上万的观测者，你可以有效地平衡内存和 CPU 轮转。</p>
<p>请注意超额订阅也会以一种非常微妙的方式存在。如果你订阅的数据确实在被使用，但不是在<strong>所有条件</strong>下都被使用（指不是在所有的分支语句中都被使用），那么这仍然算是超额订阅。例如如果 ProfileView 组件订阅了 fullName 的变化，但这个人有 nickName，这就超额订阅了（见代码 1）。所以说在 MobX 设计思想的背后有一个很重要的原则就是：</p>
<blockquote>
<p><strong>只有在运行时确定订阅，才能实现最小的、一致的订阅集合。</strong></p>
</blockquote>
<p>MobX 背后的第二个重要思想就是，对于任何复杂度超过 TodoMVC 的应用，我们通常都需要一个<strong>数据图表</strong>用来存储状态，而非标准化的树，这也是一种比较费脑子但是高效的方式。图允许引用的一致性、避免数据复制，因此可以保证衍生的数据永不过时。</p>
<hr>
<h3 id="MobX-是如何保证所有的衍生有效且一致"><a href="#MobX-是如何保证所有的衍生有效且一致" class="headerlink" title="MobX 是如何保证所有的衍生有效且一致"></a>MobX 是如何保证所有的衍生有效且一致</h3><p>解决方案就是：不缓存，只衍生。大家可能会问：这样搞不是代价很大么？不不不，事实上这样搞效率很高！原因其实上面已经解释过：MobX 并不运行所有的衍生，但能保证仅在一些响应中设计的计算值保持与可观测状态的同步。这种衍生被称作 reactive。再用电子表格的类比解释下：只有那些当前可见的公式或者一个间接使用的可见公式，在某个被观察的数据单元格发生数值变化时才需要重新计算。</p>
<h4 id="惰性求值还是响应式求值"><a href="#惰性求值还是响应式求值" class="headerlink" title="惰性求值还是响应式求值"></a>惰性求值还是响应式求值</h4><p>那么不是使用直接或间接的响应来计算呢？你仍然可以随时检查计算值（如 fullName）的值。解决方案很简单：只要计算值不是可响应的，它就会惰性求值，正如普通的 getter 函数一样。不进行任何观察的惰性衍生可以在超出范围时简单的进行垃圾回收。还记得计算值应该始终是可观察应用状态的纯函数这一说法吗？原因就是：对于纯函数无所谓惰性还是非惰性求值；对于同样的可观测状态纯函数的求值总会得出相同的结果。</p>
<h4 id="运行计算"><a href="#运行计算" class="headerlink" title="运行计算"></a>运行计算</h4><p>响应与计算值都被 MobX 用同样的方式运行。当重新计算触发时，回调函数会被推入<strong>衍生栈</strong>（当前正在运行衍生的函数栈）。只要重计算运行中，所有被访问的可观察对象将会把自己注册为衍生栈最顶部函数的依赖。如果计算值的值被衍生函数需要，且计算值已处在响应状态，那么这个值可以简单的被当做是最后一个值。否则它将把自身推入衍生栈，切换到响应模式并也开始计算。</p>
<p><img src="figure4.png" alt="图 4"></p>
  <figcaption>图 4：在执行 ProfileView 的响应期间，一些可观查状态和计算值正在被观察。计算值可能会重新计算，这形成了图 1 中展示的依赖树。</figcaption>

<p>计算完成后，我们会获得执行时访问的可观察列表。在 ProfileView 的例子里，这个列表仅包含 nickName 属性，或 nickName 和 fullName 属性。这一列表将会与前一个可观察列表进行比对。任何被移除的项将会被取消观察（计算值在这时候可能会从响应状态回退到惰性模式），任何添加的可观察这将会被观察知道下一次计算。例如 firstName 在将来发生改变，MobX 会知道 fullName 需要重新计算。这反过来将导致 ProfileView 被重新计算。下一个图标详细说明了这一过程。</p>
<h4 id="传播（Propagating）状态变化"><a href="#传播（Propagating）状态变化" class="headerlink" title="传播（Propagating）状态变化"></a>传播（Propagating）状态变化</h4><p><img src="figure5.png" alt="图 5"></p>
  <figcaption>图 5：在依赖树中修改值 1 产生的影响。虚线边框表示观察者将被标记为过时（stale）。数字表示计算的顺序。</figcaption>

<p>衍生将对状态变化自动做出响应。所有的响应都<strong>同步发生</strong>，且更重要的是<strong>十分稳定</strong>（glitch-free）。当可观察值被修改时，执行如下算法：</p>
<ol>
<li>可观察值向它的观察者发出一个<strong>过期通知</strong>（stale notification），表明它已过期。任何受影响的计算值将会递归地把这个通知传递给他们的观察者。因此依赖树的一部分将被标记为过期。在图 5 中的依赖树例子中，在值 1 发生变化时，将会过期的的观察者被橙色的虚线边框标记。这些衍生都是<strong>可能</strong>被变化的值所影响的。</li>
<li>在发送<strong>过期通知</strong>和存储新值后，一个<strong>就绪通知</strong>（ready notification）将被发送。这个消息也表明值确实发生了改变。</li>
<li>一旦一个衍生收到了在第一步中每一个过期通知来源发来的就绪通知，他就知道观察值已稳定，并将开始重新计算。对就绪/过期消息的记录将确保这一点。例如计算值 4 仅会在值 3 过期之后才会重新计算。</li>
<li>如果没有就绪消息表明值发生了改变，那衍生将简单的告诉它的观察者自己已经重新就绪了，却不改变自己的值。否则将重新计算并发送一个就绪消息给自己的观察者。这会导致如图 5 所示的计算顺序。需要注意的是最后后一个响应（被标记为 -）在计算值 4 重新求值却没有产生新值的情况下不会进行求值。</li>
</ol>
<hr>
<p>上面两段总结了可观察值和衍生之间在运行时的依赖关系，以及值的变化是如何在衍生之间传播的。现在你应该明白了一个<strong>响应</strong>基本上就是一个总是处在<strong>响应状态</strong>下的<strong>计算值</strong>。重要的是要意识到这种算法可以不用闭包，只需要用一堆指针数组便可有效实现。此外，MobX 还应用了一些本文没有讲述的其他的优化方式。</p>
<h4 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h4><p>大家经常对 MobX 的同步运行感到吃惊（这一点像 RxJs 而不像 knockout）。这样有两个很大的优点：首先这样一直观察过期的衍生变得基本不可能，因此一个衍生值在影响他的值发生变化时可以被立即使用；其次折让堆栈追从和调试变得更容易，因为它避免了 Promise/async 库中常见的的无效堆栈。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  michel.firstName = <span class="string">"Mich"</span>;</span><br><span class="line">  michel.lastName = <span class="string">"W."</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figcaption>代码 2：一个事务的例子，这确保了没人可以直接观察类似 “Mich Weststate” 的值（见代码 1）</figcaption>

<p>然而，同步执行也引入了对事务的需要。如果立即连续应用一些变化，更好的做法是在所有改变被应用之后对所有衍生重新求值。将所有行为包裹在<strong>事务</strong>（transcation）中可以实现这一点。事务简单的退出所有就绪通知知道事务块完成。注意事务仍然同步的运行和更新。</p>
<p>本文总结了 MobX 大多数基本的实现细节。我们还没有涵盖所有的东西，但这也便于你去理解，例如组合计算值。通过组合可响应的计算，甚至可以将一个数据图表自动转化为另一个数据图表，并利用最小数量的补丁（patches）将衍生值保持一致。也可以轻松实现例如 map-reduce、使用不可变数据进行状态追踪、横向数据加载等复杂模式。更多的内容请听下回分解。</p>
<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><ol>
<li>复杂应用程序的状态最好使用<strong>图形</strong>来表示，以实现引用一致性，并保持最接近问题本身的抽象模型。</li>
<li>不应该使用手动定义的订阅或游标来对状态的变化才去命令式的反应。这将不可避免的导致问题最终导致失效或超额订阅。</li>
<li>使用<strong>运行时分析</strong>来决定观察者 → 可观察对象之间关系的<strong>最小可能集合</strong>。这导致了计算模型可以在没有观察到过期值的情况下确保最少量的衍生。</li>
<li>任何不需要实现主动副作用的衍生都可以被完全的优化掉。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/10/14/An-in-Depth-Explanation-of-MobX/title.jpg&quot; title=&quot;mobx&quot;&gt;
&lt;p&gt;鉴于广大人民群众的要求（并为了到时候能给我的孙子吹个 NB），我写了这篇 MobX 的内部工作原理。许多朋友震惊于 MobX 的性能和一致性，但请各位放心，这里没有什么黑科技！&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="MobX" scheme="http://malcolmyu.github.io/tags/MobX/"/>
    
      <category term="Reactive" scheme="http://malcolmyu.github.io/tags/Reactive/"/>
    
  </entry>
  
  <entry>
    <title>细说 Charles 配置 HTTPS 代理的乱码问题</title>
    <link href="http://malcolmyu.github.io/2017/02/26/Dive-into-Charles-HTTPS-Proxying/"/>
    <id>http://malcolmyu.github.io/2017/02/26/Dive-into-Charles-HTTPS-Proxying/</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">
<p>最近因工作需要，要用 Charles 来监听 HTTPS 的请求，然而好不容易按照网上的文章配置完成之后，却发现监听的内容居然是一坨乱码。随后进行了一个 SSL 代理配置，和手机证书的安装，才终于获取到了明文。虽然之前有了解 HTTPS 是使用大素数收到进行加密，也知道有一次非对称加密和对称加密，但是经过这次的配置发现对它的根本原理还不是很了解，于是专门研究了一下，才搞明白它的原委。</p>
<a id="more"></a>
<h2 id="Charles-HTTPS-代理配置"><a href="#Charles-HTTPS-代理配置" class="headerlink" title="Charles HTTPS 代理配置"></a>Charles HTTPS 代理配置</h2><p>我们先开宗明义，把问题解决一下：要进行 HTTPS 代理配置，其实只需要两个步骤：</p>
<ol>
<li>在代理端进行 SSL 代理设置；</li>
<li>在客户端进行证书安装。</li>
</ol>
<h3 id="SSL-代理设置"><a href="#SSL-代理设置" class="headerlink" title="SSL 代理设置"></a>SSL 代理设置</h3><p>在 Charles 设置 SSL 代理，步骤为：</p>
<blockquote>
<p>Proxy –&gt; SSL Proxying Setting –&gt; Enable SSL Proxying</p>
</blockquote>
<p>之后便会看到下面的选框：</p>
<p><img src="https://7xinjg.com1.z0.glb.clouddn.com/ssl-proxying.jpeg" alt="设置SSL代理"></p>
<p>点击 Add，编辑 Loction，按照如下填写：</p>
<p><img src="https://7xinjg.com1.z0.glb.clouddn.com/edit-location.jpeg" alt="编辑Location"></p>
<p>一路点 OK，这第一步就这样成了。</p>
<h3 id="客户端证书安装"><a href="#客户端证书安装" class="headerlink" title="客户端证书安装"></a>客户端证书安装</h3><h4 id="PC-端证书安装"><a href="#PC-端证书安装" class="headerlink" title="PC 端证书安装"></a>PC 端证书安装</h4><p>假如代理的是 PC 端的 HTTPS 请求，需要在 PC 上信任 Charles 的证书，步骤为：</p>
<blockquote>
<p>Help –&gt; SSL Proxying –&gt; Install Charles Root Certificate</p>
</blockquote>
<p>选择 Charles 的证书，并信任此证书：</p>
<p><img src="https://7xinjg.com1.z0.glb.clouddn.com/trust-certificate.jpeg" alt="信任证书"></p>
<h4 id="手机端证书安装"><a href="#手机端证书安装" class="headerlink" title="手机端证书安装"></a>手机端证书安装</h4><p>在移动端安装证书，步骤为：</p>
<blockquote>
<p>Help –&gt; SSL Proxying –&gt;Install Charles Root Certificate on a Mobile Device</p>
</blockquote>
<p>之后会弹出这样一个对话框：</p>
<p><img src="https://7xinjg.com1.z0.glb.clouddn.com/install-certificate.jpeg" alt="安装证书"></p>
<p>按照上面的要求，在手机上配置好端口为 8888 的代理之后，访问 <a href="https://chls.pro/ssl" target="_blank" rel="noopener">https://chls.pro/ssl</a> 就可以下载证书并安装了。</p>
<p>实际上做完这两部，就可以在你的 PC 和移动设备上愉快的进行 HTTPS 的代理，并获取明文内容了（具体如何解决问题，也可以参考<a href="https://itangqi.me/2016/05/30/tips-for-using-charles/" target="_blank" rel="noopener">这篇文章</a>）；尽管到这一步就已经达到了实际使用的效果，但我还是产生了这样的疑问：为何进行 HTTPS 代理的配置需要配置 SSL，以及在客户端安装证书呢？之前截获的内容又为什么是乱码呢？</p>
<h2 id="乱码的缘由-——-SSL-加密"><a href="#乱码的缘由-——-SSL-加密" class="headerlink" title="乱码的缘由 —— SSL 加密"></a>乱码的缘由 —— SSL 加密</h2><p>其实稍微对 HTTPS 有点认知的童鞋，一开始就不应该对 HTTPS 截取的内容是乱码而感动吃惊：喵的这可是 HTTPS 啊，一个代理就能窃听到获明文内容，那也毫无安全性可言了吧。</p>
<p>那 HTTPS 到底是利用什么原理进行加密的呢？我们可以看到，上面的步骤中，配置 Charles 的第一步就是先配置一个 SSL 代理，实际上 HTTPS 的那个 S 也可以翻译为 HTTP over SSL/TLS，这个 SSL 正是 HTTP 加密依赖的基础协议。</p>
<p>SSL/TLS 是传输层安全协议，与其他应用层协议（如 HTTP/FTP 等）独立无关，也就是说，在应用层协议开始通信之前，SSL/TLS 协议就已经完成了相关的加密工作，后续协议传输的内容已经是加密数据了。所以其实 HTTP 还是那个 HTTP，但传输的内容早已变成天书，这也就是我们在用 Charles 进行代理的时候，看到一堆乱码的原因。</p>
<p>不过快播的审判员说的好：『文件加密了，你为什么不解密呢？』是啊，为什么经过 SSL/TLS 协议处理过的内容，不能够被解密呢？这里就涉及到 SSL 协议的基本原理，我们用写信，来模拟一下这个加密的过程：</p>
<ol>
<li>小明和小王是一对好基友，但是远隔万水千山，只能通过写信来传递消息。俩人每天的信件都是通过邮递员小红来传递的，这俩人每天纸条上<strong>明文写着信息</strong>，小红也天天看的不亦乐乎，这就是 HTTP。</li>
<li>时间久了，两人发现不行，比如有时候会传递一些不和谐的内容，不希望小红这样的腐女看到；于是小明灵机一动，换成葬爱家族的杀马特火星文来进行通信；小王看后，心领神会。由于转换方式两人都知道，这就是<strong>对称加密技术</strong>。</li>
<li>然而好景不长，小红勤学苦练，终于练成了火星文十级，又能看懂俩人加密的内容了。俩人必须要更换加密方式，但是更换的加密方式也只能通过小红来传递，所以这个加密的手段很难瞒住小红，这就是 HTTP 的不安全性。</li>
<li>正好小明是一位博学的哲♂学家，他立刻写了封信给小王：把你家储物间箱子的上那把挂锁寄过来！小王看后立刻拿出了那把 82 年的挂锁，把它打开并寄给了小明。这个锁大家都能看到，但只有小王有钥匙，这就是传说中的<strong>非对称加密</strong>，锁就是公钥，小王的钥匙就是私钥。</li>
<li>小明收到后，仔细研究了那把锁，上面烫着『隔壁老王』四个鎏金大字，正是王家祖传的锁，这就是验证服务端的<strong>数字证书</strong>。</li>
<li>于是小明放心的把新的加密方式写在信中，放到盒子里，然后用锁锁上。由于小红没有钥匙，没法查看盒子里到底写了啥，只能原样送过去。小王收到后，用自己的钥匙打开了锁，获得了新的加密方式。这就完成了 <strong>SSL 协议的握手</strong>。</li>
</ol>
<p>当然，上面的过程描述的非常粗糙，小明和小王在互相寄锁的时候，还需传递随机数来辅助生产最终的加密方式（也是一个随机数，称之为 Premaster secret）；有兴趣的兄贵们可以看看文末的参考文章。</p>
<h2 id="Charles-的破解之道"><a href="#Charles-的破解之道" class="headerlink" title="Charles 的破解之道"></a>Charles 的破解之道</h2><p>那么问题就来了：Charles 作为一只小红，是怎么破解上述加密通信的呢？莫非她大力出奇迹，直接砸了锁？我们知道，要砸锁是不太现实的，这等于要对大素数的乘积进行因式分解，现阶段下还做不到；因此 Charles 就做了一件最简单的事情：伪装成小明（也就是<a href="https://zh.wikipedia.org/zh-hk/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">中间人攻击</a>）。</p>
<p>Charles 的<a href="https://www.charlesproxy.com/documentation/proxying/ssl-proxying/" target="_blank" rel="noopener">官网上</a>是这么说的：</p>
<blockquote>
<p>Charles 作为一个中间人来进行 HTTPS 的代理，让我们检测到浏览器和 SSL web 服务端之间的明文通信。<br>Charles 把自己变成一个中间人来达到这一目的。你的浏览器是收不到服务端证书的，Charles 会用自己的根证书动态签发一张证书，然后 Charles 来接受服务端的证书，你的浏览器接受 Charles 的证书。<br>…<br>Charles 仍然通过 SSL 与服务端进行通信，但通信是通过浏览器到 Charles，然后在从 Charles 到服务器。</p>
</blockquote>
<p>那么上文所说的<strong>根证书</strong>与<strong>动态签发证书</strong>，指的是什么意思呢？这里就说到了证书的信任链体系，这是一个树状的结构，全球有为数不多的根证书颁发机构，授权二级证书颁发机构进行证书颁发；而只要用户信任了根证书，就会对其下属二级机构颁发的所有证书都予以信任。</p>
<p><img src="https://7xinjg.com1.z0.glb.clouddn.com/certificate.jpeg" alt="证书颁发体系"></p>
<p>上图可以看到 VeriSign 就是根证书颁发机构，而知乎的证书是由其二级证书颁发机构颁发的。由于操作系统里内置了对 VeriSign 的授信，因此知乎的地址栏才能有一把绿色的小锁。</p>
<p>因此 Charles 如果想对所有的域名颁发证书，必须要有一个根证书；用户信任了这个根证书，所有走 Charles 代理的 HTTPS 就都能被窃听了。</p>
<p>我们在用小红为例，复现一下这个场景：</p>
<ol>
<li>小红拿到锁以后，先扣着不发，然后掏出了自己的锁寄给小明，这就是 Charles 签发了自己根证书；</li>
<li>小明一看这把锁不是正宗王家的，但是小红家的锁，似乎也可以相信，这就是<strong>信任了 Charles 的根证书</strong>；</li>
<li>小明把加密方式写进去，然后用小红的锁锁起来了，小红打开之后研究了加密方式，发现两人是在用水星文进行交流，瞬间水星文也达到了十级，然后在换上小王的锁锁上了盒子，还给了小王；</li>
<li>小王毫不知情，之后俩人用水星文进行交流，但内容已经全被小红捕获到了。</li>
</ol>
<p>搞明白这些之后，我们再来看一下，为什么要进行 Charles 的那两个配置呢？</p>
<ol>
<li>设置 SSL 代理：因为默认 HTTP 请求走的是 80 端口，HTTPS 请求走的是 443 端口，不设置的话 Charles 仅会默认更改系统的 HTTP 代理，只有 HTTP 流量会走 Charles，而设置这个 HTTPS 的流量才会从这儿走；</li>
<li>安装 Charles 的根证书：根据信任链，只要安装一下 Charles 的根证书，之后 Charles 颁发的所有域名的证书都能被自动信任，因此 HTTPS 就都能被窃听了。</li>
</ol>
<p>把证书的信任链翻译到锁上，等于小明会预先信任几个大厂生产的锁，比如只要是老王牌的锁，那我都相信，其他人也可以用这类锁来跟我要加密方式；Charles 等于创造了一个小红五金厂，把所有代理的请求都挂上了小红锁。那么 12306 其实跟小红一样，由于某些原因没有大厂申请一个锁，而是自己开了一个老铁五金厂，然后跟用户说：『相信我铁道部的老铁五金厂的锁吧，不然你就憋想回家！』</p>
<p>用户还能怎么办？只能含着泪点确认：『老铁，没毛病！』</p>
<p>参考文献</p>
<ol>
<li><a href="https://zhihu.com/question/22306245/answer/21002652" target="_blank" rel="noopener">支付宝偷偷添加根证书 - 知乎</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解 SSL/TLS</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS 协议运行机制的概述</a></li>
<li><a href="https://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/" target="_blank" rel="noopener">细说 CA 和证书</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因工作需要，要用 Charles 来监听 HTTPS 的请求，然而好不容易按照网上的文章配置完成之后，却发现监听的内容居然是一坨乱码。随后进行了一个 SSL 代理配置，和手机证书的安装，才终于获取到了明文。虽然之前有了解 HTTPS 是使用大素数收到进行加密，也知道有一次非对称加密和对称加密，但是经过这次的配置发现对它的根本原理还不是很了解，于是专门研究了一下，才搞明白它的原委。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://malcolmyu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="http://malcolmyu.github.io/tags/HTTPS/"/>
    
      <category term="SSL" scheme="http://malcolmyu.github.io/tags/SSL/"/>
    
      <category term="TLS" scheme="http://malcolmyu.github.io/tags/TLS/"/>
    
      <category term="Charles" scheme="http://malcolmyu.github.io/tags/Charles/"/>
    
  </entry>
  
  <entry>
    <title>闲聊 Redux（下）</title>
    <link href="http://malcolmyu.github.io/2017/02/02/Chat-about-Redux-2/"/>
    <id>http://malcolmyu.github.io/2017/02/02/Chat-about-Redux-2/</id>
    <published>2017-02-01T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="/2017/02/02/Chat-about-Redux-2/title.png" title="redux">
<p><a href="/2016/12/03/Chat-about-Redux-1/">上文</a>里，我们剥茧抽丝，聊了聊 Redux 里面的各种烦人概念，以及这些概念是怎么来的；本文我们着重聊一聊，让 Redux 大行其道的『中间件』。</p>
<a id="more"></a>
<h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>宏观意义上的中间件（middleware），定义十分模糊，只要能弥合底层操作系统之间差异，对不同顶层应用提供支持的软件，都算是中间件。按照笔者自己的理解，传统意义的中间件更像是一层封装，掩盖了底层的实现细节、提升了开发效率，例如游戏引擎、<a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank" rel="noopener">JDBC</a>，甚至 jQuery 也算是广泛意义上的中间件。然而自动 TJ 大神搞了 Express 之后，中间件这个概念在前端的语境下也产生了一些变化，它逐渐的变成了一种<strong>对框架的扩展方式</strong>，成为一种开放接口，用户可以通过自行编写中间件，控制数据在框架内部的流动方式、数据的内容，或者是函数的应用方式。</p>
<p>拿 Express 来说，它的中间件实现的就是<strong>数据与控制的集合</strong>，它可以对 https 请求的请求（request）和相应（response）数据进行更改，并通过 <code>next</code> 方法进行对中间件的控制，让中间件的编写者有能力控制中间件的<strong>进入与错误终止</strong>。React-Router 的中间件技术也主要是一套异步控制手段，在 <code>onEnter</code> 生命周期中加入了对异步行为的支持，异步的中间件可以通过调用 <code>next</code> 方法，自行控制进入到下一个中间件的时间点。</p>
<p><img src="https://ww1.sinaimg.cn/large/7921624bjw1fccmekzhe7j207805e74j.jpg" alt="著名的中间件洋葱示意图"></p>
<p>在 Redux 这里呢，中间件的含义又发生了变化，Redux 官方文档这样说道：</p>
<blockquote>
<p>Redux 中间件与 Express 和 Koa 的中间件解决的问题并不相同，但二者在概念上却高度一致。<strong>从一个 action 被调度（dispatch），到这个 action 到达 reducer，中间件在这两个时刻中间提供了一个第三方扩展的植入点</strong>。</p>
</blockquote>
<p>Redux 的中间件确实与 Express 和 Koa 的中间件神似，它处理了 action 的流动，并使用 next 控制下层中间件的进入，并提供了中间件的中断功能。我们就来看一下它是怎么实现这些功能的吧。</p>
<h2 id="中间件的使用探索"><a href="#中间件的使用探索" class="headerlink" title="中间件的使用探索"></a>中间件的使用探索</h2><p>既然 Redux 中间件的作用就是处理 action 的流动，那我们就先来看下，不使用中间件的时候，action 是怎样流动的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务代码中调度 action</span></span><br><span class="line">store.dispatch(action)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 中处理 action，返回 state</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Redux 内部是隐藏了 action 流动细节的，但是我们在之前的<a href="/2016/12/03/Chat-about-Redux-1/#dispatch：更新状态、触发回调">精简代码</a>中有看到，在执行 <code>dispatch</code> 之后，就会通过 <code>currentReducer</code> 来获取最新的状态。也就是说，执行 dispatch，遍历 reducer 是一个<strong>同步的过程</strong>。这一点非常重要，不过目前仅仅是进行日志记录，我们还并不关系它是同步还是异步。</p>
<p>我们接着就上面的代码来看，如果要实现 action 的日志记录，应该怎么办呢？当然，最快速也最耦合的办法，就是在业务代码中写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">store.dispatch(action)</span><br><span class="line"><span class="comment">// dispatch 是个同步的过程，dispatch 之后 state 就会发生改变</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br></pre></td></tr></table></figure>
<p>这样的写法当然很不友好，总不能在每次书写业务代码的时候，都写上这样一坨内容吧。那我们来想一下，我们期望用户在业务里书写的方式是什么呢？实际上就只要写一个 <code>store.dispatch(action)</code> 就可以了，不希望还有多余的操作；而这个日志记录，应该是作为顶层中间件，注入到这个 store 当中。这也就等于说，用户在执行 <code>store.dispatch</code> 的时候，实际上应该依次执行我们顶层注入的中间件的逻辑。</p>
<p>换句话说，<strong>Redux 中间件实际上是对 <code>store.dispatch</code> 方法的劫持</strong>。</p>
<p>意识到这一点，我们的程序也好写了，可以先通过 hack 的方式劫持一下 <code>dispatch</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchLog</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = store.dispatch</span><br><span class="line">  store.dispatch = <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">    <span class="keyword">const</span> result = dispatch(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的写法虽然可行，但显然扩展性不强，一个扩展的场景还勉强够用，多个中间件同时存在就没法写了。有的童鞋也许会说，其实还是可以写的啊，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">patchLog(store)</span><br><span class="line">patchSomething(store)</span><br></pre></td></tr></table></figure>
<p>但是通过赋值修改 <code>dispatch</code> 的方式有个两个非常严重的问题：</p>
<ol>
<li>传给第后面中间件的 store，它的 <code>dispatch</code> 方法已经被劫持了，这也就意味着通过这种方式无法给后续的中间件传递原始的 <code>store.dispatch</code> 方法。显然，这一点我们是无法接受的，因为原始的 <code>store.dispatch</code> 方法的调用，意味着中间件执行的<strong>结束</strong>；后续的中间件无法调用它，就失去了中断中间件执行的能力。</li>
<li>用户在中间件里调用 <code>store.dispatch</code>，直接导致栈溢出；</li>
</ol>
<p>我们来看一下 Redux 官方都是怎样应用中间件的，且怎样解决了以上两个问题。</p>
<h2 id="官方中间件实现方式"><a href="#官方中间件实现方式" class="headerlink" title="官方中间件实现方式"></a>官方中间件实现方式</h2><p>中间件的编写，官方是这样实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchLog = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">  <span class="keyword">const</span> result = next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间件的应用，官方是这样实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">applyMiddleware(patchLog, patchSomething)(store);</span><br></pre></td></tr></table></figure>
<p>我们先来看下 Redux <code>applyMiddleware</code> 方法的精简实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 reduceRight 确保先应用的中间件先执行</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = middlewares.reduceRight(</span><br><span class="line">      (next, middleware) =&gt; middleware(store)(next),</span><br><span class="line">      store.dispatch</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; ...store, dispatch &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，Redux 的 <code>applyMiddleware</code> 通过一个技巧很好的解决了上面两个问题：<strong>返回全新的 store 对象</strong>。这确保原有 store 的 <code>dipatch</code> 方法没有被覆盖，且很好的保留了原始 <code>dispatch</code> 对象（就是 <code>store.dispatch</code>）。用户在中间件中可以自行选择调用 <code>store.dispatch(action)</code> 或是 <code>next(action)</code>：前者表示终止后续中间件的执行，直接将 action 送给 reducer；后者表示将 action 送给后续的中间件并继续执行。</p>
<h2 id="异步中间件"><a href="#异步中间件" class="headerlink" title="异步中间件"></a>异步中间件</h2><p>介绍完官方中间件的实现与使用方式，我们再来看一下业务中必然会用到的<strong>异步中间件</strong>。在上文中我们说过：执行 dispatch 之后遍历 reducer 是一个<strong>同步的过程</strong>，那怎么执行异步操作呢？这也好办，因为上文我们也说过，<strong>Redux 中间件实际上是对 <code>store.dispatch</code> 方法的劫持</strong>，所以只要在异步的时间点去执行 <code>dispatch</code> 就行了。</p>
<p>我们来看一下著名的 <a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="noopener">redux-thunk</a> 中间件的源码与用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">store.dispatch(<span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步触发 dispatch 打到异步效果</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'AN_ANCTION'</span> &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里我们看到，该中间件会检测 action 是否是函数，如果是函数则将原始 <code>dispatch</code> 方法当做函数的参数传入并调用函数（这意味后面的中间件会被当前中间件阻断）；否则将 action 丢给下一个中间件。</p>
<p>从这里我们可以看出，实际上所有的异步中间件实现，本质上都是因为 Redux 的中间件机制提供了一个切入点，让用户可以自行控制 action 流向 reducer 的时机和 action 的内容；控制的方式就是实现一个 wrapper 来接替原始的 <code>dispatch</code> 方法，并在 wrapper 中可以异步执行原始 <code>dispatch</code>。</p>
<p>至于异步中间件的选型，本文不会详细介绍，可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/24337401" target="_blank" rel="noopener">Redux 异步方案选型</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管 Redux 框架与 15 年刚刚问世的盛极一时相比已经风光不再，但它精巧的设计、良好的解耦与扩展性，以及中间件的扩展方式，都值得我们在进行设计框架时效仿学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/02/02/Chat-about-Redux-2/title.png&quot; title=&quot;redux&quot;&gt;
&lt;p&gt;&lt;a href=&quot;/2016/12/03/Chat-about-Redux-1/&quot;&gt;上文&lt;/a&gt;里，我们剥茧抽丝，聊了聊 Redux 里面的各种烦人概念，以及这些概念是怎么来的；本文我们着重聊一聊，让 Redux 大行其道的『中间件』。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="Redux" scheme="http://malcolmyu.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Hybrid 路由架构演进之路</title>
    <link href="http://malcolmyu.github.io/2017/01/14/The-Evolution-of-Hybrid-Router/"/>
    <id>http://malcolmyu.github.io/2017/01/14/The-Evolution-of-Hybrid-Router/</id>
    <published>2017-01-13T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>经过近两年的发展，我们去哪儿内部的 hybrid 方案 hy，已经从 15 年年中的 hy 1.0 进一步完善和成熟，已于去年底推出了基于 react 的 hy2.0 解决方案。在框架升级的大背景下，他的路由架构体系也发生了不小的变化，希望能通过这篇文章，让大家了解到我们路由方案的选择变迁，与页面加载性能优化的手段。</p>
<a id="more"></a>
<h2 id="Hy-1-0-架构"><a href="#Hy-1-0-架构" class="headerlink" title="Hy 1.0 架构"></a>Hy 1.0 架构</h2><p>我们来看一下这样一个页面，它是我们 YMFE Conf 的邀请函：</p>
<p><img src="https://ww3.sinaimg.cn/large/7921624bjw1fbagpi7541g20aa0ickbe.gif" alt="邀请函"></p>
<p>这个页面效果非常的炫，但是有一个显著的问题，『慢』。看到这个图片，我的脑海中就浮现出三个大字：<strong>SPA</strong>。相比大家对此都深有感触，一方面，在当时 SPA 代表着 h5 应用的尖端水准，它利用 h5 的 history-api，让前端能自由的控制浏览器历史，从而脱离后端，自主掌控路由；另一方面，由于一个页面要加载全部的静态资源，页面渲染完成之前漫长的 loading 动画成为了用户对 SPA 应用最深刻的印象。</p>
<p>而我们的 Hy 1.0 架构，就是基于 SPA 实现的路由系统，我们所有的页面都是单页应用，在一进入首页时加载所有资源。</p>
<p>为什么我们要采用这一套系统呢？这个跟当时的环境与我们的解决方案有很大的关系。在两年前，许多安卓手机的浏览器性能还比较差，在页面回退的时候没有页面缓存，需要重新刷新，在这种场景下，显然使用 SPA 来进行开发，用户的体验会更接近原生应用；我们在客户端上采用离线包机制，用户在打开 app 时会自动更新离线包，这样很大程度上也可以避免首页加载时间过长的问题。</p>
<p>Hy 1.0 架构体系如下：</p>
<p><img src="https://7xnghq.com1.z0.glb.clouddn.com/1.0.png" alt="Hy 1.0"></p>
<p>然而，随着安卓手机性能的提升，现在很多浏览器都会进行页面缓存，实现页面切换的动画，所以单页和多页给用户的体验差不多；在 iOS 上，SPA 的动画与原生的手势回退动画会产生冲突；更重要的是，在 hybrid 环境下，我们采用的是多 webview 的解决方案，这一方案本身就是多页的 —— 这是在 hy 1.0 里始终无法逾越的一个问题：每次打开一个新 webview，实际我们只显示众多页面中的一个页面，但实际展示却要<strong>加载全部的资源</strong>，这实际是很不合理的。</p>
<p>针对这一问题，我们进行过很多讨论，既然现在 touch 的多页跟单页在手机上的体验差距也没有那么大，而且每页加载的资源体积更少，那是不是直接回归到之前的多页开发就行呢？</p>
<p>这种方式也有一定的优势：至少我们前端的开发量变少了 —— 不用控制路由逻辑，甚至依赖的代码体积还能更少一点。但这样带来的弊端也十分明显：灵活性变差了，往简单来说，如果一个 app 在某种场景下必须是 spa，比如整个应用可能会被离线保存为 file 协议，那这种依赖纯后端路由的手段就难以实现；往大了说，前端失去了对路由的控制权，以后增减页面可能都需要后端配合，或者修改后端工程。这种不便给我们带来的问题，显然是多于给我们节省的那点开发量的。</p>
<p>那么到底有没有一种方案，可以使我们的路由能够在单页/多页之间自由转换，而且还能让单页和多页应用都能实现资源的按需加载呢？</p>
<h2 id="Hy-2-0-架构"><a href="#Hy-2-0-架构" class="headerlink" title="Hy 2.0 架构"></a>Hy 2.0 架构</h2><p>我们 Hy2.0 架构选择的是使用 webpack 代码分割实现资源异步加载，使用 react-router 实现资源按需加载，我们通过这样的技术选型，打到了上面既要有性能，又要有自由的目标。</p>
<h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>我们先来看一下，js 资源异步加载的原理，将代码分割为首屏渲染需要的逻辑 A，与其他页面所需的静态资源逻辑 B，在入口页面引入 A，然后在 A 内向页面插入带有 async 属性的 script 标签，引入静态资源 B。</p>
<p><img src="https://7xnghq.com1.z0.glb.clouddn.com/async-load.png" alt="异步引入资源"></p>
<p>但是我们的 js 文件通常不是单独工作的，每个文件之间可能复杂的互相依赖的模块关系，因此在将文件拆分之后，还需要使用一种类似 jsonp 的方式，让被拆分的文件调用一个挂载在 window 上的函数，获取入口文件的模块依赖，并将自己的模块注入到全局模块中。</p>
<p>通过这样的手段，我们就可以实现代码的异步加载，并能很好的处理模块间的依赖关系，那么还有一个问题没有解决，那就是怎么控制代码的分割点呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'A.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'B.js'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>webpack 给我们提供了一个非常简易的方式，使用 <code>require.ensure</code> 关键字，就可以区分文件是否被分片打包。如果正常书写 <code>require(&#39;A.js&#39;)</code>，这个 js 文件就会和入口文件一起打到一个文件中；但是如果使用 <code>require.ensure</code> 关键字，在回调中调用 <code>require(&#39;B.js&#39;)</code> 那么这个文件就在打包的时候打成一个独立的分块。webpack 会在 <code>require.ensure</code> 执行的时候，在页面异步加载这个独立的分块。</p>
<h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>我们想一想，按需加载，那应该需是什么呢？我们想 spa，又想能顺利过渡多页，其实是一个单页应用，每次打开新页面重新加载，且仅加载本页面所需的资源。这样才能做到所以与后端控制路由的多页没有本质的区别。因此最大的需求，就是按页面加载，而路由正是按页面加载最好的分割点。</p>
<p>react-router 本身提供了强大的异步支持，它的核心方法 <code>match</code> 方法本身就是通过回调层层传递的，因此通过 react-router 来支持异步按需加载也十分的容易。</p>
<p>我们来看一下 react-router 同步配置的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/"</span>&gt;</span><br><span class="line">    &lt;IndexRoute component=&#123;HomePage&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"list"</span> component=&#123;List&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"detail"</span> component=&#123;Detail&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么将它修改为异步的方式，只需要将 <code>Route</code> 的配置组件的属性 <code>component</code> 修改为 <code>getComponent</code> 即可，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"list"</span> getComponent=&#123;(_, cb) =&gt; &#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([], () =&gt; &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./List'</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>但是由于 react-router 本身有一套复杂的异步配置流程，加上 <code>require.ensure</code> 语法本身也是比较繁琐，因此整个配置流程对用户来说很不友好，我们在自己的 Hy 框架中，使用 babel 插件的方式对代码进行解析，提供了便捷的语法糖 <code>requre.async</code>，让异步引用变得更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="built_in">require</span>.async(<span class="string">'./list'</span>);</span><br><span class="line"></span><br><span class="line">&lt;Route path=<span class="string">"list"</span> getComponent=&#123;List&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>那么采用这套新架构体系，有没有遇到什么问题呢？确实也遇到一些问题，其中最主要的就是拆分粒度和离线包打包的问题。</p>
<h3 id="拆分粒度问题"><a href="#拆分粒度问题" class="headerlink" title="拆分粒度问题"></a>拆分粒度问题</h3><p>既然我们选择了资源异步加载的方案，那么是不是必须严格按照页面来进行资源拆分呢？答案是不确定的，因为毕竟每次新开请求也有额外的资源消耗，我们给定一个公式，认为 <strong>体积 &gt; 网速 * TTFB（首字节响应时间）</strong> 的资源无需进行拆分。比如 4G 网 TTFB 0.02s，网速 800k/s，那么体积小于 800k/s * 0.02s = 16k 的资源就不应该进行拆分，因为新开请求的消耗大于加载资源的消耗。</p>
<h3 id="离线包打包问题"><a href="#离线包打包问题" class="headerlink" title="离线包打包问题"></a>离线包打包问题</h3><p>还有一个比较棘手的问题是离线包的打包的问题，因为我们之前的离线包打包方案是采用入口文件进行打包的，使用 webpack 生成的 chunk 是非入口文件，按照原有的逻辑就不会被打到离线包里，因此我们修改了离线包打包工具的逻辑，并在发布的时候支持打出一个入口 json，让离线包读取这个 json 来进行非入口文件的打包，这样才解决的了这个问题。</p>
<p>新架构体系如下：</p>
<p><img src="https://7xnghq.com1.z0.glb.clouddn.com/2.0.png" alt="Hy 2.0"></p>
<p>通过这套新架构，我们 app 的首屏渲染性能得到了显著的提高，最主要的是，我们编写的 app 能够自由的在单页、多页和 hybrid 场景下进行切换，这样就涵盖了业务在不同场景下、适应不同情况的需求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过近两年的发展，我们去哪儿内部的 hybrid 方案 hy，已经从 15 年年中的 hy 1.0 进一步完善和成熟，已于去年底推出了基于 react 的 hy2.0 解决方案。在框架升级的大背景下，他的路由架构体系也发生了不小的变化，希望能通过这篇文章，让大家了解到我们路由方案的选择变迁，与页面加载性能优化的手段。&lt;/p&gt;
    
    </summary>
    
      <category term="架构分析" scheme="http://malcolmyu.github.io/categories/%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Hybrid" scheme="http://malcolmyu.github.io/tags/Hybrid/"/>
    
      <category term="webpack" scheme="http://malcolmyu.github.io/tags/webpack/"/>
    
      <category term="react-router" scheme="http://malcolmyu.github.io/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>闲聊 Redux（上）</title>
    <link href="http://malcolmyu.github.io/2016/12/03/Chat-about-Redux-1/"/>
    <id>http://malcolmyu.github.io/2016/12/03/Chat-about-Redux-1/</id>
    <published>2016-12-02T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img src="/2016/12/03/Chat-about-Redux-1/title.png" title="redux">
<p>Redux 算是 React 全家桶里最饱受争议的一个框架，就算是天天变 API 的 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">React-Router</a>，也因为占据了意识形态的最高点 —— 便捷优雅的声明式路由、异步路由控制与加载，导致尽管骂声不断，却没有一个人说不用。反观 Redux，用不惯的说它夹杂了太多的私心，找遍业务线所有的代码，也找不到一个逻辑用到这么复杂的函数式；用的惯的也嫌它使用太复杂，凭空多出几个文件夹、丑陋的 <code>switch</code>、一遍一遍的常量声明，真是端起键盘开发，放下鼠标骂娘。与 React-Router 横行社区不同，Redux 从来不缺竞争者，前有 Reflux，后有 <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">Mobx</a>；但似乎也没见有一个竞争者真正撼动 redux 的地位：完美适配服务端渲染，完善的调试工具与社区支持，都让 Redux 成为 React 学习者首选的数据流框架。</p>
<p>今天就来简单聊聊这个可能是这两年最火的数据流框架：<a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">Redux</a>。</p>
<a id="more"></a>
<p>本文将分为上下两部分，在第一部分中我们会聊一聊 Redux 那些烦人的概念，在第二部分中我们会聊一聊『中间件』这一使 Redux 获得社区广泛支持的大杀器。</p>
<h2 id="烦人的概念"><a href="#烦人的概念" class="headerlink" title="烦人的概念"></a>烦人的概念</h2><p>没用过 Redux 的开发者打开它的文档，扑面而来就是难懂的概念，什么 <code>compose</code>、<code>applyMiddleware</code>、<code>reducer</code> 之类，引得大家都尴尬了起来，关了网页翻身又刷知乎去了。实际上我个人认为，把这些繁杂的概念丢到 Redux 的首页介绍上简直就是一个败笔，这些东西实际上都是在后来的开发过程中，高度抽象的业务逻辑，根本没有必要直接介绍给用户。</p>
<p>那 Redux 到底是个啥咧？我们抛去这些复杂的概念不看，先看看我们开发中最常用到的，也是最核心的概念：<a href="https://cn.redux.js.org/docs/basics/Store.html" target="_blank" rel="noopener">store</a>。这个 store 顾名思义，就是一个数据存储的结构，我们可以自己先自己脑补一下，实现一个数据存储需要写什么功能呢？大概不外乎就是『获取数据』、『存储数据』，但是 Redux 的 store 显然不是这么简单，因为在修改数据之余，我们还需要监听数据变化，以便进行一些其他的操作：比如跟着修改组件监听的 <code>props</code>；而这个数据监听的行为，实际上是由使用者定义的，因此还需要接入一套事件管理的机制：『订阅事件』、『取消订阅』、『事件发布』。</p>
<p>简单来说，Redux 的 store 就是<strong>数据管理与事件订阅的组合</strong>，实际上，这个基本的内核也并非 Redux 的原创，而是 Facebook 最早提出来的 <a href="https://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a> 的概念。翻一下它的<a href="https://github.com/reactjs/redux/blob/master/src/createStore.js#L247" target="_blank" rel="noopener">源码</a>，可以明显的看到它对外提供了三个方法：<code>dispatch</code>，<code>subscribe</code> 和 <code>getState</code>，翻译一下就是『调度』、『订阅』和『状态获取』。这个 <code>getState</code> 就不多说了，就是获取一份 store 的当前数据，我们重点聊一聊 <code>dispatch</code> 和 <code>subscribe</code>。</p>
<h3 id="dispatch：更新状态、触发回调"><a href="#dispatch：更新状态、触发回调" class="headerlink" title="dispatch：更新状态、触发回调"></a>dispatch：更新状态、触发回调</h3><p>我们说 store 是数据管理与事件订阅的组合，那么 <code>dispatch</code> 方法就是 store 最核心的功能。看一下它代码的精简版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 通过 Reducer 遍历 action，更新 state</span></span><br><span class="line">  currentState = currentReducer(currentState, action)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 触发通过 subscribe 订阅的回调</span></span><br><span class="line">  <span class="keyword">var</span> listeners = currentListeners = nextListeners</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> listener = listeners[i]</span><br><span class="line">    listener()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 返回 action</span></span><br><span class="line">  <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是简洁明了？基本上就干了两件事：<strong>更新当前状态</strong>，<strong>触发监听回调</strong>。读者也许会问，这里的 <code>currentReducer</code> 方法是个啥，<code>listeners</code> 又是哪里注册的？我们按下不表，只简单的说一下：前者跟 <code>reducer</code> 这个概念有关，我们随后会讲到；后者就是 <code>subscribe</code> 方法注册的，等下也会细说。</p>
<p>注意到，<code>dispatch</code> 函数的参数是 action，这个东西的含义我们会在讲 reducer 的时候<a href="#核心的思想">简单说明</a>。</p>
<p>其实笔者个人认为，最需要注意的一点是上面注释中的第三点：<strong><code>dispatch</code> 方法的返回值是 action</strong>。也就是说，对于没有使用中间件，或中间件也遵守这一原则的情况下，是可以利用 <code>dispatch</code> 方法的返回值，来处理一些贴近业务的耦合代码，例如使用了 <a href="https://github.com/acdlite/redux-promise" target="_blank" rel="noopener">redux-promise</a> 中间件时，我们可以获取 <code>dispatch</code> 的返回值的 <code>payload</code> 属性（它是那个处理中的 promise），然后等这个 <code>payload</code> 处理完成后进行一些业务逻辑操作。</p>
<h3 id="subscriber：注册回调、做好清理"><a href="#subscriber：注册回调、做好清理" class="headerlink" title="subscriber：注册回调、做好清理"></a>subscriber：注册回调、做好清理</h3><p>我们再来看下 <code>subscriber</code> 代码的精简版，同样是非常的好理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 注册回调</span></span><br><span class="line">  nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 返回清理函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = nextListeners.indexOf(listener)</span><br><span class="line">    nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总共又是干了两件事，第一是把回调注册到 <code>nextListeners</code> 中，供 <code>dispatch</code> 时调用；第二是返回一个清理注册函数的函数，便于用户进行注册函数的清理。这里要注意的，就是第二步清理函数。react 初心者应该都会遇到下面的这行错误提示：</p>
<p><img src="https://ww1.sinaimg.cn/large/7921624bgw1fb55pktexgj21kw01qdhl.jpg" alt="setState 错误"></p>
<p>导致这个错误的原因，就是异步调用 <code>setState</code>，结果执行的时候，由于异步的关系，代码所在的组件都被销毁了。当你使用 redux 时，你会发现基本不会出现这样的提示，那就是因为 redux <strong>在组件销毁的时候调用了清理函数</strong>，因此所有能导致状态发生变化的操作都会在组件移除时被清理。</p>
<h2 id="精神内核"><a href="#精神内核" class="headerlink" title="精神内核"></a>精神内核</h2><p>说完 redux 跟 flux 相关的内核，再说下 redux 独有的特性：reducer。reducer 是传入给 <code>createStore</code> 的参数，是创建 store 的最基本依赖。先说下 reducer 是什么，这东西基本等于 flux 中 <a href="https://facebook.github.io/flux/docs/dispatcher.html" target="_blank" rel="noopener">dispatcher</a> 的升级版。dispatcher 翻译过来就是『调度器』，我们知道 <code>dispatch</code> 是『进行调度』，<code>subscribe</code> 是『监听调度』，那 reducer 就是处理『怎么调度』。</p>
<p>如要实现下面这个简单的功能：</p>
<p><img src="https://ww1.sinaimg.cn/large/7921624bgw1fb5blrrg9vg204101pwed.gif" alt="简单的例子"></p>
<p>就需要编写这样一个 reducer：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用就是根据 action 的类型来处理对 <code>state</code> 的改变，既然多次提到了 action，我们先解释一下它。</p>
<h3 id="action：仅仅是个对象"><a href="#action：仅仅是个对象" class="headerlink" title="action：仅仅是个对象"></a>action：仅仅是个对象</h3><p>它是一个<strong>纯对象</strong>，且必须带一个 <code>type</code> 属性。</p>
<p>为什么要这样设计呢？想象一下上面的例子：我们对数字进行修改，点左边减少、点右边增加，那么每一次点击就会触发一次 action —— 因为每点击一次状态肯定会发生改变；但是左边的点击和右边的点击触发的肯定是<strong>不同的 action</strong> —— 因为改变状态的方式不同。区分 action 的就是它的 <code>type</code> 属性（在这个例子里就是 <code>&#39;INCREMENT&#39;</code> 和 <code>&#39;DECREMENT&#39;</code>）；而不同 action 对应的不同操作就是由 reducer 来处理（如上面的 <code>state + 1</code> 和 <code>state - 1</code>）。</p>
<p>根据 action，Redux 还衍生出一个 <code>actionCreator</code> 的概念 —— 其实这个概念也很无聊，它指代一个 action 的创造函数，毕竟从用户行为转换到 action 对象还需要一些过程，比如下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementIfOdd</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: <span class="string">'INCREMENT'</span>,</span><br><span class="line">      payload: num</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子，对 action 进行了逻辑处理，只有奇数才会触发 <code>dispatch</code> 行为。这里你可能会注意到，它返回的并非一个纯对象，这是因为使用了 <a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="noopener">redux-thunk</a> 中间件，action 的形态就从纯对象变为函数，这在下篇中会有所讲述。</p>
<h3 id="reducer：可以自由组合的调度器"><a href="#reducer：可以自由组合的调度器" class="headerlink" title="reducer：可以自由组合的调度器"></a>reducer：可以自由组合的调度器</h3><p>从上面的例子中，我们可以看到 reducer 的主要功能是进行状态的改变的调度控制。但这并非 reducer 的特色，其实它最大的特色正如其名，是进行状态树的<strong>缩减合并</strong>。这是什么意思呢，我们先看一段 js 数组 reducer 的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125; ];</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> (&#123; ...next, <span class="attr">child</span>: prev &#125;), &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会变成这样的对象：</span></span><br><span class="line"><span class="comment">// &#123; c: 3, child: &#123; b: 2, child: &#123; a: 1, child: &#123;&#125; &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>那么，redux 的 reducer 也起到了类似的作用（尽管它的源码没有一行用到 <code>reduce</code> 函数😂），它可以将我们编写的调度器 reducer 集合起来，最终集合成一个调度器树。这样做的意义在于，在保证了<strong>唯一状态树的前提</strong>之下，我们在编码时还能只关注状态调度的某一细节。那么集合 reducer 的方法呢，就叫做 <a href="https://redux.js.org/docs/api/combineReducers.html" target="_blank" rel="noopener"><code>combineReducers</code></a>。</p>
<p><img src="https://7xinjg.com1.z0.glb.clouddn.com/combined-redux.png" alt="combineReducer"></p>
<p>这里我们就不对具体的 API 进行讲解了，综合来说，reducer 带给 redux 最大的特性就在于：<strong>编码时关心单个 reducer，但最终生成统一调度器，调度生成单一的状态树</strong>。</p>
<h2 id="compose：函数式编程的私货"><a href="#compose：函数式编程的私货" class="headerlink" title="compose：函数式编程的私货"></a>compose：函数式编程的私货</h2><p>Redux 有一个单独的概念，叫做 compose，这其实是函数式编程里面的一个套路，可以单拿出来说一说。</p>
<p>前一阵阮老师翻译过一本《黑客与画家》，曾经掀起过一阵 lisp 学习小高潮。lisp 是一门函数是一等公民的语言，万物皆函数，要处理一个顺序逻辑，基本上就得这么写：<code>a(b(c(d(e()))))</code>，所以打开你的 lisp 代码，最后几行基本是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">        ))))))))))))</span><br><span class="line">      ))))))))</span><br><span class="line">    )))))</span><br><span class="line">  ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这简直就是阻碍函数式编程普及的恶魔啊！不过没关系，这里要将的 <code>compose</code> 方法，就是起到代码美化作用的：它可以把上面的 <code>a(b(c(d(e(123)))))</code> 改成：<code>compose(a,b,c,d,e)(123)</code>。是不是瞬间有了活下去的动力？</p>
<p>我们来考虑考虑，在 ES6 里，这个函数应该怎么写：</p>
<ol>
<li>首先我们应该把传入的一坨函数改造成数组，这个 ES6 里面的 <a href="https://es6.ruanyifeng.com/#docs/function#rest参数" target="_blank" rel="noopener">rest 参数</a>已经帮我们很好的搞定了；</li>
<li>其次我们需要<strong>逆序</strong>执行函数，这就可以用到 <code>reduceRight</code>。</li>
</ol>
<p>我们来实现一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> last = funcs.pop();</span><br><span class="line">   <span class="keyword">let</span> rest = funcs;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> rest.reduceRight(<span class="function">(<span class="params">compose, f</span>) =&gt;</span> f(compose), last(...args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个函数，就可以进行函数的连接操作了。当然，在上篇介绍的基本概念里并没有用到它的地方，它真正的用处还是在于下篇的中间件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Redux 一些基本理念，剥去 Redux 神秘的面纱，我们发现它就是一个 flux 内核加 reducer 缩减组合的套路，后面这个套路好像还是从 Elm 里面抄的。下篇我们会对 Redux 的扩展手段『中间件』进行详细的讲解，这才是令 Redux 大行其道的最重要原因。</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2016/12/03/Chat-about-Redux-1/title.png&quot; title=&quot;redux&quot;&gt;
&lt;p&gt;Redux 算是 React 全家桶里最饱受争议的一个框架，就算是天天变 API 的 &lt;a href=&quot;https://github.com/ReactTraining/react-router&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React-Router&lt;/a&gt;，也因为占据了意识形态的最高点 —— 便捷优雅的声明式路由、异步路由控制与加载，导致尽管骂声不断，却没有一个人说不用。反观 Redux，用不惯的说它夹杂了太多的私心，找遍业务线所有的代码，也找不到一个逻辑用到这么复杂的函数式；用的惯的也嫌它使用太复杂，凭空多出几个文件夹、丑陋的 &lt;code&gt;switch&lt;/code&gt;、一遍一遍的常量声明，真是端起键盘开发，放下鼠标骂娘。与 React-Router 横行社区不同，Redux 从来不缺竞争者，前有 Reflux，后有 &lt;a href=&quot;https://github.com/mobxjs/mobx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mobx&lt;/a&gt;；但似乎也没见有一个竞争者真正撼动 redux 的地位：完美适配服务端渲染，完善的调试工具与社区支持，都让 Redux 成为 React 学习者首选的数据流框架。&lt;/p&gt;
&lt;p&gt;今天就来简单聊聊这个可能是这两年最火的数据流框架：&lt;a href=&quot;https://github.com/reactjs/redux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redux&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="Redux" scheme="http://malcolmyu.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>前后端同构之路</title>
    <link href="http://malcolmyu.github.io/2016/10/24/Create-React-Universal-App/"/>
    <id>http://malcolmyu.github.io/2016/10/24/Create-React-Universal-App/</id>
    <published>2016-10-23T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>公司内部的公用图标字体平台 iconfont 上线一年以来，运行良好，在内部承担起了客户端减容、提高前端开发效率的任务。但由于其臃肿的架构导致的运行效率底下和页面卡顿等问题也一直给使用者造成诸多不便。我们对项目老架构导致的许多问题进行了探索总结，并针对问题提出了 react 同构的解决方案。</p>
<a id="more"></a>
<h2 id="旧版架构问题探索"><a href="#旧版架构问题探索" class="headerlink" title="旧版架构问题探索"></a>旧版架构问题探索</h2><p>在进行旧版平台开发的时候，我们采用了当时淘宝推出的先进思想：<a href="https://www.zhihu.com/question/23512853" target="_blank" rel="noopener">中途岛 midway 前后端分离方式</a>，搭建了一个 node 中间层进行页面的渲染，以求提升页面的渲染速度。我们旧版平台的结构如下：</p>
<p><img src="http://s.qunarzz.com/iconfont/blog/universal-app/old-architecture.png" alt="旧版平台的三层结构"></p>
<p>从图中我们可以看到，尽管我们前端掌握了 server，可以进行页面渲染的控制，但是服务端的渲染和前端的渲染和路由依然是割裂的，之间有很多冗余的内容。导致这些冗余的主要原因，其实还是前后端渲染方式不一致以及前后端代码的分离。</p>
<h3 id="是否需要前后端分离"><a href="#是否需要前后端分离" class="headerlink" title="是否需要前后端分离"></a>是否需要前后端分离</h3><p>我们知道，在传统的 MVC 架构的项目之中，js 代码只占 View 层的很小的一部分。随着项目的渐进发展，前端功能的复杂度日益增高，导致项目难以维护；同时前后端语言并不一致（我们都知道 Java 跟 JavaScript 基本上是雷锋和雷峰塔的关系），不同的开发在一个项目里操作极为不便，因此才产生了前后端分离。</p>
<p>但是随着 js 向服务端的进发，我们的中间层 server 也采用支持 js 的 node 来进行架构，所以前后端语言不一致的问题基本上抹平了；而前端功能复杂这一点，从刚才的分析我们也可以看到，其实前端和后端在路由、渲染这些功能上是有很大的重合，因此前端的 server 和前端逻辑项目没有必要进行分离。</p>
<p>实际上，这里我们的前后端分离，已经有传统意义上前端和后端代码的分离、服务端和浏览器客户端的分离，演变为后端数据提供和前端提供渲染的分离。</p>
<h3 id="前后端混合渲染的问题"><a href="#前后端混合渲染的问题" class="headerlink" title="前后端混合渲染的问题"></a>前后端混合渲染的问题</h3><p>如果将前后端代码糅合在一起，那么渲染这里将会是服务端逻辑和客户端逻辑的一个结合点，它们的模板、渲染方式都一定要一致，才能减少开发的工作量。</p>
<p>对于我们旧版项目来说，服务端采用 handlebars 作为模板，而前端采用 MVVM 模式的 avalon 的模板，两者在用法和理念上都是有一定冲突的。其中 MVVM 模式在服务端渲染中最棘手的问题就是：<strong>要实现双向数据绑定，必须要经历一次 DOM 渲染</strong>。这样就导致后端只能渲染一个中间状态的模板，然后还需要前端在更改一次 DOM，无法达到『直出』的效果。</p>
<p><img src="http://s.qunarzz.com/iconfont/blog/universal-app/back-to-front.png" alt="前后端渲染模板差异"></p>
<p>这个问题看似困难，但在 react 出现之后，却得到了完美的解决：react 基于 virtual DOM，不需要扫描 DOM 来建立双向绑定关系，只需要在每次状态变动时进行 diff，有变化才会进行更新。因此，我们可以在服务端直接渲染出 DOM 结构，如果前端最终生成的虚拟 DOM 跟后端直出的 DOM 保持一致，那么就不需要更改 DOM 结构，大幅度提升渲染速度。</p>
<h2 id="同构应用的构建"><a href="#同构应用的构建" class="headerlink" title="同构应用的构建"></a>同构应用的构建</h2><p>如果要实现前后端代码同构，其实只要保证两个一致即可：<strong>包管理工具</strong>和<strong>模块依赖方式</strong>的一致。这里我们可以看到，这二者的一致性都能得以保证：</p>
<ol>
<li>包管理工具：前端和 node 目前都采用 npm 来进行依赖管理，这就保证客户端和服务端都可以使用同一个兼容包；</li>
<li>模块依赖方式：通过 webpack 这样的打包工具，可以保证前端和均采用 CommonJS 的依赖方式，确保代码可以互相依赖。</li>
</ol>
<p>有了这二者的保证，我们就可以完美的解决同构的问题，剩下需要考虑的就是如何处理服务端渲染了。</p>
<h2 id="react-全家桶对服务端渲染的支持"><a href="#react-全家桶对服务端渲染的支持" class="headerlink" title="react 全家桶对服务端渲染的支持"></a>react 全家桶对服务端渲染的支持</h2><p>react 自诞生之初就对服务端渲染非常重视，它的『全家桶』都对服务端渲染进行了良好的支持。所谓的『全家桶』指的就是大家耳熟能详的 react 御三家：<a href="https://facebook.github.io/react/" target="_blank" rel="noopener">react</a>、<a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">react-router</a> 和 <a href="http://redux.js.org/" target="_blank" rel="noopener">redux</a>。</p>
<p><img src="http://s.qunarzz.com/iconfont/blog/universal-app/react-everything.png" alt="react 全家桶"></p>
<h3 id="React-和-ReactDOM"><a href="#React-和-ReactDOM" class="headerlink" title="React 和 ReactDOM"></a>React 和 ReactDOM</h3><p>ReactDOM 在这里提供的支持就是 <code>ReactDOM.render</code> 和 <code>ReactDOM.renderToString</code> 函数，其中前者会在浏览器端生成 DOM 结构，后者会在服务端生成对应的 HTML 字符串模板。React 会在生成的 DOM 结构上添加一个 <code>data-react-checksum</code> 的属性，这是一个 adler32 算法的校验和，用以确保两份模板的一致性。</p>
<p><img src="http://s.qunarzz.com/iconfont/blog/universal-app/checksum.png" alt="checksum 判断"></p>
<p>同时 react 的生命周期在前后端渲染过程中也有所不同。前端渲染的组件拥有完整的生命周期，而后端渲染仅有 <code>componentWillMount</code> 的生命周期。这就意味着，如果我们想进行前后端共同操作的逻辑，如发送数据请求等，可以放在 <code>componentWillMount</code> 的生命周期中；如果想单独处理客户端的逻辑，可以放在其他生命周期，如 <code>componentDidMount</code> 中。</p>
<h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><p>react-router 是 react 的路由 - 视图控制库，可以书写便捷的声明式路由以控制不同页面的渲染。react-router 本身是一个状态机，根据配置好的路由规则，和输入的 url 路径，通过 <code>match</code> 方法找到对应的组件并进行渲染。</p>
<p><img src="http://s.qunarzz.com/iconfont/blog/universal-app/react-router.png" alt="react-router 原理"></p>
<p>这套机制在前端和后端都是相通的，例如在后端，就是下面这样一种实现形式来进行渲染：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  match(&#123;</span><br><span class="line">    location: ctx.originalUrl,</span><br><span class="line">    routes</span><br><span class="line">  &#125;, callback)</span><br><span class="line">  <span class="comment">// 渲染完成之后，调用 callback 回调</span></span><br><span class="line">  <span class="comment">// 将 &lt;RouterContext&gt; 组件 renderToString 返回前端即可</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于前端来说，其实也是处理的上面这些逻辑，不过它被很好的封装在 <code>&lt;Router&gt;</code> 组件中，我们只需要写好声明式的路由，这一切就可以随着 url 的变化自动发生。</p>
<h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>redux 是 react 的数据流管理库，它对服务端渲染的支持很简单，就是<strong>单一 store</strong>和<strong>状态可初始化</strong>。后端在进行渲染的时候会构建好单一的 store，并将构建好的初始状态通过以 JSON 格式，通过全局变量写到生成好的 HTML 字符串模板上。前端通过获取初始状态，生成跟后端渲染完成后一模一样的 store，就可以保证前后端渲染数据的一致，以确保前后端生成 DOM 结构的一致。</p>
<h2 id="项目优化成果总结"><a href="#项目优化成果总结" class="headerlink" title="项目优化成果总结"></a>项目优化成果总结</h2><p>项目在使用了 react 进行同构构建之后，首屏渲染性能得到了明显的提升，之前页面大约 1500ms 才能展示关键数据，而之后的页面只需要 230ms 就可以进行数据展示了。</p>
<p><img src="http://s.qunarzz.com/iconfont/blog/universal-app/render.png" alt="性能对比"> </p>
<p>同时项目得到了精简，由之前的两个项目合并为一个，代码也得以通用。</p>
<p>项目经过 react 同构，之前的许多问题都得以解决：</p>
<ol>
<li>开发效率低的问题：同构应用只有一个项目和一套技术栈，只要拥有 react 开发经验，就可以快速投入前端和后端的开发当中；</li>
<li>可维护性差的问题：同构应用可以进行大量的代码公用，包括工具方法、常量、页面组件和 redux 的大部分逻辑等，可重用性大大提高；</li>
<li>首屏性能、SEO 等：有了服务端渲染，麻麻再也不担心首屏和 SEO 问题啦。</li>
</ol>
<p>其实新的 react 服务端渲染架构并不是对之前『中途岛』的推翻，而是它理念的演进，核心思想都是由服务端来控制渲染，只是这里将之前互不干涉的前后端项目糅合到了一起，使用同构的方式简化了渲染层的工作。对于已使用 node 中间层的项目，不妨尝试一下 react 同构的技术方案，它会使你的开发效率和首屏性能得到飞速提升。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司内部的公用图标字体平台 iconfont 上线一年以来，运行良好，在内部承担起了客户端减容、提高前端开发效率的任务。但由于其臃肿的架构导致的运行效率底下和页面卡顿等问题也一直给使用者造成诸多不便。我们对项目老架构导致的许多问题进行了探索总结，并针对问题提出了 react 同构的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="架构分析" scheme="http://malcolmyu.github.io/categories/%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="react" scheme="http://malcolmyu.github.io/tags/react/"/>
    
      <category term="universal" scheme="http://malcolmyu.github.io/tags/universal/"/>
    
  </entry>
  
  <entry>
    <title>读《叫魂：1768年中国妖术大恐慌》</title>
    <link href="http://malcolmyu.github.io/2016/04/02/Reaction-to-Soulstealers/"/>
    <id>http://malcolmyu.github.io/2016/04/02/Reaction-to-Soulstealers/</id>
    <published>2016-04-01T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在弘历的这一任上，大清的盛世梦达到了最高潮。自17世纪开始，玉米、番薯、马铃薯等美洲粮食作物引入中国，战乱的平定和粮食产量的增长使得大清的人口数量翻了一番，从 1.5 亿达到了 3 亿之巨；由于西班牙人在南美的掠夺，导致白银大量流入，尽管带来的一定程度的通货膨胀，却也推动了贸易与土地交易的欣欣向荣。然而在这繁华盛世的背后，独坐龙椅的弘历叔叔却也感到了自己的中年危机。</p>
<a id="more"></a>
<h2 id="弘历的忧虑与民众的狂欢"><a href="#弘历的忧虑与民众的狂欢" class="headerlink" title="弘历的忧虑与民众的狂欢"></a>弘历的忧虑与民众的狂欢</h2><p>由于大清国情的问题，全体社会财富增加的盛世，往往意味着官僚阶层的严重腐败。弘历对于官员们私下捞捞钱的态度，显然比胤禛老爷子要宽容的多；但是腐败带来的问题，却让皇上感到头疼。尽管弘历自己也去江南腐败了好几趟，但他也同时觉得这种奢靡的文化对于满人勤劳勇敢的先进性造成了极大的腐蚀。腐败带来的问题还不仅于此，繁华江南量产的士子们朋比结党，影响朝中的政治风气；地方官僚们在考绩中官官相护，使得整个监督体系形同虚设。简而言之，整个官僚体系已经形成了一个坚实的整体，犹如一架精密有序的机器，即使是拥有绝对权威的君主，也很难干扰它上面任何一个齿轮的运行节奏。</p>
<p>这使得皇上的意志对于官僚的影响逐级递减，中央对地方不能如臂使指——这才是令弘历最为头疼的一个问题。通常来讲，皇帝对官僚有两个常规的手段来进行一定程度的控制：考绩和监察。然而大清立国已百年，考绩评语日趋拘谨呆板，官员上下级形成一道紧密的关系网，上级对下级的考评除去那些有重大问题的，基本都是好顶赞；监察机构更不用说，基本都是各省的官员在自己监督自己。面对日趋形式化的评定系统，弘历不得不独辟蹊径，采用自己的手段：比如入京陛见，以及在各省安插眼线等。然而在承平日久的大清，这些动作都很难起到太大的影响，整个官僚机器还是那样缓慢有序的运作着，让皇上的手腕显得有些左支右绌。</p>
<p>然而叫魂案却给了弘历一个契机。这样一场席卷全国的事件，必然有他的主谋——或许幕后有妄图颠覆大清的谋反者也说不定。通过这个『谋反案』，国家进入了<strong>非常规态势</strong>，皇帝的手里握着一张『政治罪』的王牌，终于可以将专制的手段介入地方，严饬那些已经抱成一团的地方官员。或许在事件的前期，皇上还是发自肺腑的对叫魂事件的影响表示担忧；但是到了事件的后期，见证了一切荒诞与冤屈还依然坚持的皇上，是不是有几分是在贪恋这半年间获得的对官僚系统至高无上的支配权呢？</p>
<p>反观底层的民众，太平盛世给他们带来的好处，或许没有想象中那样多。尽管粮食产量与社会财富显著上涨，但人口也成倍的增加了，人均资源占有率甚至还有下降的趋势；地区发展不均衡也是一个很大的问题，与苏杭地区的繁华雅致相比，叫魂案发的安徽广德就『僻处万山之中，与徽郡接壤，可耕之田无几，兼以水少潍汇，田皆瘠薄』。人民没有因为商业的快速发展而显得更加优游从容，反而压力更大了。在帝国发展的中后期，社会的上升渠道也逐渐被垄断，『冷籍』<sup><a href="#note-1">注1</a></sup> 在现实中屡受刁难。作者在书里说：</p>
<blockquote>
<p>在这样一个倍受困扰的社会里，人们会对自己能否通过工作或学习来改善自身的境遇产生怀疑。这种情况由于腐败而不负责任的司法制度而变得更加无法容忍，没有一个平民百姓会指望从这一制度中得到公平的补偿。</p>
</blockquote>
<p>对于长期缺失权利的底层民众，叫魂案件给他们长期以来被压抑的情绪带来了一个爆发口。相信妖术的人，渴望通过叫魂这种超自然的方式，打击报复自己的对手；不相信妖术的人，也可以利用官府清剿的契机，诬告他人为叫魂犯。这种底层权力幻觉的产生导致的暴乱，在历史上似乎多次存在；然而似乎每一次的类似叫魂的案件，都仅仅是社会无组织力量 <sup><a href="#note-2">注2</a></sup> 扩大化的插曲，最终的结局往往是席卷全国的起义与革命。</p>
<p>就在弘历叔叔晚年把自己的签名改成『十全老人』之后数年，川楚地区便爆发了旷日持久的白莲教起义，八旗、绿营等中央正规军被彻底打崩，地方团练兴起，中央对地方的控制力日趋下降，弘历叔叔的担心终于变成了现实。好在他已死去，无需亲自来面对这盛世崩塌之后的风雨飘摇。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>不得不说，作为一名学者，孔飞力教授的文笔令人惊叹。书里的前八章对于叫魂事件的描述几乎可以当做小说来看：他将一起夺人眼球的怪力乱神案件——德清石匠案作为入口，展开了长达五章的娓娓道来；他不厌其烦的刻画了下层普通民众的生存状态、中层乡绅官僚的权利博弈、上层乾隆皇帝的内心写照，最终勾勒出一幅十八世纪中叶大天朝的全景图；最后又一口气将这些社会阶层用叫魂案件结合在一起，全书矛盾冲突激烈迸发；然而这震动的大清半壁江山案件却是一场冤案和闹剧，它的结局只能是高潮之后戛然而止，草草收场。在深夜的飞机上一口气全部读完而不觉困顿，足以说明这本书的吸引力。</p>
<p>尽管像我这样心术不正的读者，读这本书就是为了寻找『现实中历史的影子』 <sup><a href="#note-3">注3</a></sup>，但还是被教授对当时的官僚体系和各阶层任务心理的论述所折服。教授在第三章对弘历同志作为一个满族征服者兼帝国统治者，对剃发问题的微妙心理把握的极为巧妙；对底层民众对僧、乞的态度，以及对叫魂的特殊恐惧也刻画的入木三分。今年 2 月，孔飞力教授与世长辞，愿天国安息。</p>
<p><strong>注释</strong></p>
<ul>
<li><p><b id="note-1">注1</b>：冷籍，指祖辈无科考，却来参加应试的子弟，虽然合法，却会遭受排挤刁难，清末状元张謇就因冷籍而需冒籍考试。</p>
<blockquote>
<p>冷籍者，雖身家淸白，但三代無人與考，其子孫出而應試，則羣詆爲冷籍</p>
</blockquote>
</li>
<li><p><b id="note-2">注2</b>：无组织力量是金观涛夫妇在《兴盛与危机：论中国社会超稳定结构》一书中的提法。</p>
</li>
<li><p><b id="note-3">注3</b>: 本书自出版时，便遇上震动全国的某轮事件，适时书里内容一直被读者拿来与现实做参照，以至于本书的译者都在札记里说：</p>
<blockquote>
<p>他所讨论的全是历史，对现实并无半点影射。我们之所以在读此书时会感到似曾相识，那是因为现实中还常常有历史的影子罢了。</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在弘历的这一任上，大清的盛世梦达到了最高潮。自17世纪开始，玉米、番薯、马铃薯等美洲粮食作物引入中国，战乱的平定和粮食产量的增长使得大清的人口数量翻了一番，从 1.5 亿达到了 3 亿之巨；由于西班牙人在南美的掠夺，导致白银大量流入，尽管带来的一定程度的通货膨胀，却也推动了贸易与土地交易的欣欣向荣。然而在这繁华盛世的背后，独坐龙椅的弘历叔叔却也感到了自己的中年危机。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://malcolmyu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="叫魂" scheme="http://malcolmyu.github.io/tags/%E5%8F%AB%E9%AD%82/"/>
    
  </entry>
  
  <entry>
    <title>读《人类简史》</title>
    <link href="http://malcolmyu.github.io/2016/01/12/Reaction-to-A-Brief-History-of-Humankind/"/>
    <id>http://malcolmyu.github.io/2016/01/12/Reaction-to-A-Brief-History-of-Humankind/</id>
    <published>2016-01-11T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自从去年妹子给买了 kindle 之后，前前后后读了很多书，起初的一半读得多是魏晋南北朝的门阀政治，到了后来看了些心理学的，由于一直未做笔记，总觉得没有长进。去年年底去医院挨刀子，穷极无聊之间读了这本《人类简史》，一下子就被书里新奇诡黠的内容吸引了，两天读完电子版，事后还买了纸质版以供仔细阅读。书里记载了许多新奇有趣的观点，我总结了三点，分别对应书里的认知革命、农业革命和科技革命。</p>
<a id="more"></a>
<h2 id="幻想组织了人类社会"><a href="#幻想组织了人类社会" class="headerlink" title="幻想组织了人类社会"></a>幻想组织了人类社会</h2><p>不错，我们这个社会是由幻想组织的，这才是我们与其他动物之间最根本的区别。对于图腾崇拜和神灵的幻想让原始智人组织了超过150人的大型群落，最终称霸全球；对于社会主义的幻想让我兔领导大众夺取了天下。图腾、神灵和社会主义都是看不见摸不着的东西，却长存人心，这真是一个发人深思的事情。之前看权力的游戏时，蜘蛛和小恶魔的对话令人叫绝：</p>
<blockquote>
<p>蜘蛛：『三位贵人坐在一个房间中：一个国王，一个僧侣和一个富翁。三人之间，站着一名普通佣兵，每位贵人都命佣兵杀死另外二人。孰生，孰死？』<br>小恶魔：那要视那个佣兵而定。<br>蜘蛛：是吗？他既没有王冠，也无金银珠宝，更没有神明的眷顾。<br>小恶魔：但他有利剑，有决定生死的力量。<br>蜘蛛：既然生死取决于士兵，那我们为什么又假装承认国王的权利至高无上呢？奈德·史塔克人头落地，应该负责的究竟是谁？乔佛里？刽子手？还是别的什么东西？<strong>权力存于人心。信则有，不信则无。惑人的把戏，如浮影游墙。即便是矮小之人，也能投射出巨大的影子。</strong></p>
</blockquote>
<p>以前看这些对白的时候，并不是很理解权力存于人心的意义；后来看了本书中的观点，感觉似乎确如蜘蛛所说：力量是最初的决定因素，而不是最终的；是个体的，而非群体的。对于个人来说，能发挥的力量终究是有限的；而对于群体来说，能够发挥力量的恰恰是组织术：正是有效的组织使得成千上万人的群落、部队、球场的观众能够井然有序，目标专一。知乎里有一个著名的问答：<a href="https://zhihu.com/question/20529731/answer/36331627" target="_blank" rel="noopener">第二次国共内战时期，国民党战败主要是因为军事策略失误吗？</a> 中督公就在答案里提到，我兔之所以战胜，最根本的原因还是有着强大的组织动员能力。而组织最重要的一点，就是能营造出一种所有人都深信不疑的幻想，或者说是理想。</p>
<p>那么人类社会的组织结构是怎么产生的呢？</p>
<h2 id="对剩余价值的剥削产生了阶级和帝国"><a href="#对剩余价值的剥削产生了阶级和帝国" class="headerlink" title="对剩余价值的剥削产生了阶级和帝国"></a>对剩余价值的剥削产生了阶级和帝国</h2><p>书里提到，15000年前，全世界的人类开始不约而同的种起了小麦。有了农作物之后，人类的物资开始丰盈，不必过着东奔西走的采摘、捕猎生活，并且开始进行定居。之后人类开始了对于<strong>未来</strong>的忧虑——在原始的采集社会，人类对于未来是完全没有概念的。对于未来的忧虑使得人类开始进行囤积，最终产生了大量的剩余价值。</p>
<p>然而不知是幸运还是不幸，物资的丰富并没有使它的制造者们过上更好的日子，反而产生了新的阶层：精英阶层。他们收取赋税，不误农事，从事着政治、军事和艺术的研究。他们的生活日趋优异，而农民们却深陷贫穷。作者在书里说：农业革命实际上是一个骗局，它让更多的人以更糟的状态生活下去。</p>
<p>久而久之，形成了庞大的帝国，也带来了永世不灭的<strong>阶级</strong>。多年以来，无数人在消灭阶级的道路上付出了毕生的努力，所有的尝试却依然被历史的车轮碾碎。魏武为了铲除士族，杀孔杀杨，甚至不惜与荀令君闹翻；然而人亡政息，两百年后士族的权利居然大到可以裹挟皇权，寒门子弟即使身居高位，在士族家里竟也无席可坐。尽管在乱世之时，阶级的人员会发生大规模的流动；但一旦国家统一、社会安定，阶级也会逐渐稳固下来。核心成员们依靠血缘组成庞大的堡垒，并制定规则使堡垒合法化；控制着有限的流通渠道，让堡垒外的符合自己要求的人能稍微挤进来。本朝太祖也曾想摧毁这堡垒，然而却酿成了灾难和悲剧，留下累世恶名。</p>
<p>尽管如此，农业革命还是让大规模的人类得以聚集，依靠<strong>金钱、帝国和宗教</strong>，构筑起庞大的群落——尽管只有中国这样的神奇民族能够把如果广阔的疆域维持几百年的时间，大部分时间欧亚各国都是一团乱麻。那些盛极一时的大型帝国，如倭马亚王朝、查理曼大帝国，基本都随着创始者的死去而即刻分崩离析。然而在500年前，力量的天平却开始悄悄倾斜：当明武宗正德同志还躲在豹房自嗨的时候，西班牙人科尔特斯仅以千人便征服了墨西哥的阿兹特克帝国；十几年之后，弗朗西斯科·皮萨罗更是仅用200人便灭亡了南美的印加帝国。欧洲的征服者们贪婪的踏上这些陌生的土地，攫取了大量的财富。等到他们强大的军事能力能够快速投放到中国这片古老的土地上时，天朝的子民才发现这惊人的差距。</p>
<p>那为何胜利的女神选择了欧洲呢？</p>
<h2 id="现代科学与资本主义的结合"><a href="#现代科学与资本主义的结合" class="headerlink" title="现代科学与资本主义的结合"></a>现代科学与资本主义的结合</h2><p>大概是欧洲的贫瘠与美洲的富足造成了这一切。1484年，哥伦布老师谒见西班牙的伊莎贝拉女王，希望女王能够资助它的舰队绕地球航行发现去东亚的新航线。尽管哥伦布老师最终也没能找到印度在哪儿，但却让西班牙人征服了美洲，获得了无尽的金银矿产、蔗糖和烟草。这一切使得航海家们获得了更多的资助，<del>开启了寻找 One Piece 的大航海时代，</del>构成了<strong>资本主义信贷</strong>的奇妙循环：投资带来回报，回报建立信任，信任又转化为更多的信贷；而庞大的中国大陆就没有这么幸运，在科技的曙光到来之前，励精图治的皇帝们已经建立起的官僚阶级已经将触角伸向社会各个角落，大洋和荒漠之外无可发掘，他们只关心税收，对于信贷一无所知。</p>
<p>信贷的力量，从荷兰的崛起中可窥一斑。在14世纪中叶，小小的荷兰想要挑战庞大的西班牙帝国，可谓是蚍蜉撼树，然而短短的几十年之内，荷兰利用司法独立和保护个人财产的方式，取代了蛮横无理的西班牙王室，获得了欧洲金融体系的信任。随着大量资金的流入，荷兰人不但建立了世界上第一座证券交易所，还取代了西班牙人成为了新一代的海上霸主。它的继任者英国也是走着一样的路子，伦敦证券交易所一支支股票发行，暗示了欧洲金主对这个新兴帝国的赞许与支持。资本主义的力量在欧洲政府世界的过程中展现的淋漓尽致，无怪乎冰火里也要有一个布拉佛斯铁金库的神奇设定。</p>
<p>帮助欧洲征服者们征服世界的，除了病菌与枪炮，还有<strong>科学</strong>。英国征服印度之后，动用了数以万计的劳工和学者，对这个文明古国进行了彻头彻尾的大调查，绘制了精密的地图、勘探了各种矿藏资源、挖掘了被遗忘的废墟、发现了印度梵文和语言体系。对于被统治地区的详尽调查，使得统治者们比当地土著还要了解这个大陆；正是知识与科学使得几十万驻印的英国人得以奴役3亿印度人长达两个世纪之久。</p>
<p>正如相信欧洲之外会有美洲，我们也会相信宇宙深处或是原子核里都蕴含着巨大的能量。因此现在的国家也像当年的伊莎贝拉女王一样，资助着那些研究室里的探索者们继续前行，按照 <strong>投资–&gt;科技进步–&gt;探索征服–&gt;带来丰厚回报–&gt;继续投资</strong> 的正向循环步步向前。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从去年妹子给买了 kindle 之后，前前后后读了很多书，起初的一半读得多是魏晋南北朝的门阀政治，到了后来看了些心理学的，由于一直未做笔记，总觉得没有长进。去年年底去医院挨刀子，穷极无聊之间读了这本《人类简史》，一下子就被书里新奇诡黠的内容吸引了，两天读完电子版，事后还买了纸质版以供仔细阅读。书里记载了许多新奇有趣的观点，我总结了三点，分别对应书里的认知革命、农业革命和科技革命。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://malcolmyu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人类简史" scheme="http://malcolmyu.github.io/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>协程与事件循环</title>
    <link href="http://malcolmyu.github.io/2015/11/18/Coroutine-and-Event-Loop/"/>
    <id>http://malcolmyu.github.io/2015/11/18/Coroutine-and-Event-Loop/</id>
    <published>2015-11-17T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.782Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近研究了一下 es6 的生成器函数，以及传说中的 co。虽然网上关于协程、co 源码分析的文章数不胜数，但是将其与先前异步实现的事件队列结合起来说明的文章却很难寻觅。之前只知道协程是实现异步的一种方式，那其和之前的各种异步实现究竟有什么本质区别呢？本文将根据协程机制简要探讨一下<strong>引入协程之后的新的事件循环模型</strong>。由于笔者基础知识不够扎实，所以会先讲述一大堆协程产生的背景和原理，再进行模型变化的讲解。</p>
<a id="more"></a>
<h2 id="协程实现机制"><a href="#协程实现机制" class="headerlink" title="协程实现机制"></a>协程实现机制</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>说起协程就不得不提到面试宝典必备题目之一：啥是进程啥是线程他俩有啥区别？ 之前阮一峰老师写过一篇<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">博文</a>进行科普，但是文中将电力比作 CPU 以及用厕所比喻锁都不合适。反而是评论里有位叫 viho_he 的哥们说的不错，在这里简单的把他的思路整理一下：</p>
<ol>
<li>单核 CPU 无法被平行使用。为了创造『共享』CPU 的假象，搞出了一个叫做时间片的概念，给任务分配时间片进行调度的调度器后来成为操作系统的核心组件；</li>
<li>在调度的时候，如果不对内存进行管理，那么切换时间片的时候会造成程序上下文的互相污染。但是手工管理物理地址实在是太蛋疼了，因此引入了『虚拟地址』的概念，共包含三个部分：<ul>
<li>CPU 增加了内存管理单元模块，来进行虚拟地址和物理地址的转换；</li>
<li>操作系统加入了内存管理模块，负责管理物理内存和虚拟内存；</li>
<li>发明了一个概念叫做<strong>进程</strong>。进程的虚拟地址一样，经过操作系统和 MMU 映射到不同的物理地址上。</li>
</ul>
</li>
<li>深入的谈一谈进程。进程是由一大堆元素组成的一个实体，其中最基本的两个元素就是<strong>代码</strong>和能够被代码控制的<strong>资源</strong>（包括内存、I/O、文件等）；一个进程从产生到消亡，可以被操作系统<strong>调度</strong>。掌控资源和能够被调度是进程的两大基本特点。但是进程作为一个基本的调度单位有点不人性：假如我想一边循环输出 hello world，一边接收用户输入计算加减法，就得起俩进程，那随便写个代码都像 chrome 一样变成内存杀手了。</li>
<li>因此诞生了<strong>线程</strong>的概念，线程在进程内部，处理并发的逻辑，拥有<strong>独立的栈</strong>，却共享线程的资源。使用线程作为 CPU 的基本调度单位显得更加有效率，但也引发各种抢占资源的问题<del>，使得笔试又多了一个考题</del>。</li>
</ol>
<p>最后总结一下就是：进程掌握着独立资源，线程享受着基本调度。一个进程里跑多个线程处理并发，6 的飞起。但纯粹的内核态线程有一个问题就是性能消耗：线程切换的时候，进程需要为了管理而切换到内核态，状态转换的消耗有点严重。为此又产生了一个概念，唤做<strong>用户态线程</strong>。用户态线程吼啊，程序自己控制状态切换，进程不用陷入内核态，会玩儿的开发者可以按照程序的特性来选择更适合的调度算法，代码的效率飞了起来。</p>
<h3 id="协程、子例程与生成器"><a href="#协程、子例程与生成器" class="headerlink" title="协程、子例程与生成器"></a>协程、子例程与生成器</h3><p>那协程是干啥的咧？实际上，协程的概念产生的非常早，<a href="https://en.wikipedia.org/wiki/Melvin_Conway" target="_blank" rel="noopener">Melvin Conway</a> 早在 1963 年就针对编辑器的设计提出一种将『语法分析』和『词法分析』分离的方案，把 token 作为货物，将其转换为经典的<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">『生产者-消费者问题』</a>。编译器的控制流在词法和语法解析之间来回切换：当词法模块读入足够多的 token 时，控制流交给语法分析；当语法分析消化完所有 token 后，控制流交给词法分析。从这一概念提出的环境我们可以看出，协程的核心思想在于：<strong>控制流的主动让出和恢复</strong>。</p>
<p>这一点和上文说的用户态线程有几分相似，但是用户态线程多在语言层面实现，对于使用者还是不够开放，无法提供显示的调度方式。但是协程做到了这一点，用户可以在编码阶段通过类似 <code>yieldto</code> 原语对控制流进行调度。</p>
<p>说到这里可能有读者会产生疑问：『我大协程这么吊，为何提出了这么多年一直不火啊？』这就要说到当年命令式编程与函数式编程的『剑气之争』，当年命令式编程围绕着自顶向下的开发理念，将子例程调用作为唯一的控制结构。实际上，子例程就是没用使用 <code>yield</code> 的协程，大宗师 <a href="https://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">Donald E. Knuth</a> 也曾经曰过：</p>
<blockquote>
<p>子例程是协程的一种特例。</p>
</blockquote>
<p>但不进行让步和恢复的协程，终究失掉了协程的灵魂内核，不能称之为协程。直到后来出现了一个叫做<strong>迭代器（Iterator）</strong>的神奇的东西。迭代器的出现主要还是因为数据结构日趋复杂，以前用 <code>for</code> 循环就可以遍历的结构需要抽象出一个独立的迭代器来支持遍历，用 js 为例。迭代器的遍历会搞成下面这个样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">": "</span> + obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，要实现这种迭代器的语法糖，就必须引入协程的思想：主执行栈在进入循环后先让步给迭代器，迭代器取出下一个迭代元素之后再恢复主执行栈的控制流。这种迭代器的实现就是因为内置了<del>葛炮</del><strong>生成器（generator）</strong>。生成器也是一种特殊的协程，它拥有 <code>yield</code> 原语，但是却不能指定让步的协程，<strong>只能让步给生成器的调用者或恢复者</strong>。由于不能多个协程跳来跳去，生成器相对主执行线程来说只是一个可暂停的玩具，它甚至都<strong>不需要</strong>另开新的执行栈，只需要在让步的时候保存一下上下文就好。因此我们认为生成器与主控制流的关系是不对等的，也称之为<strong>非对称协程（semi-coroutine）</strong>。</p>
<p>由此我们也知道了，为啥 es6 一下引起了这么一大坨特性啊，因为引入迭代器，就必须引入生成器，这俩就是这种不可分割的基友关系。</p>
<h2 id="现有协程的实现"><a href="#现有协程的实现" class="headerlink" title="现有协程的实现"></a>现有协程的实现</h2><p>自 es6 尝试引入生成器以来，大量的协程实现尝试开始兴起，协程一时间成为风靡前端界的新名词。但这些实现中有的仅仅是实现了一个看上去很像协程的语法糖，有的却 hack 了底层代码，实现了真正的协程。这里以 TJ 大神的 <a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a> 和 <a href="https://github.com/laverdet/node-fibers" target="_blank" rel="noopener">node-fibers</a> 为例，浅析这两种协程实现方式上的差异。</p>
<h3 id="CO"><a href="#CO" class="headerlink" title="CO"></a>CO</h3><p>co 实际上是一个语法糖，它可以包裹一个生成器，然后生成器里可以使用同步的方式来编写异步代码，效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = f1.toString().length + f2.toString().length;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 es7 中已经推出了一个更甜的语法糖： <code>async/await</code>，实现效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = f1.toString().length + f2.toString().length;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>是不是碉堡了！这段代码仿佛是在说明：我们把 <code>readFile</code> 丢到另一个协程里去了！等他搞定之后就又回到主线程上！代码可读性 6666 啊！但事实真的是这样的么？我们来看一下 co 的不考虑异常处理的精简版本实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> def = <span class="built_in">Promise</span>.defer();</span><br><span class="line">    <span class="keyword">let</span> iter = gen();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复迭代器并带入promise的终值</span></span><br><span class="line">        step(iter.next(data));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">it</span>) </span>&#123;</span><br><span class="line">        it.done ?</span><br><span class="line">            <span class="comment">// 迭代结束则解决co返回的promise</span></span><br><span class="line">            def.resolve(it.value) :</span><br><span class="line">            <span class="comment">// 否则继续用解决程序解决下一个让步出来的promise</span></span><br><span class="line">            it.value.then(resolve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve();</span><br><span class="line">    <span class="keyword">return</span> def.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 co 的代码实现可以看出，实际上 co 只是进行了对生成器让步、恢复的控制，把让步出来的 promise 对象求取终值，之后恢复给生成器——这都没有多个执行栈，并没有什么协程么！但是有观众会指出：这不是用了生成器么，生成器就是非对称协程，所以它就是协程！好的，我们再来捋一捋：</p>
<ol>
<li>协程在诞生之时，只有一个 Ghost，叫做<strong>主动让步和恢复控制流</strong>，协程因之而生；</li>
<li>后来在实现上，发现可以采用可控用户态线程的方式来实现，因此这种线程成为了协程的一个 shell。</li>
<li>后来又发现，生成器也可以实现一部分主动让步和恢复的功能，但是弱了一点，我们也称生成器为协程的一个弱弱的 shell。</li>
<li>所以我们说起协程，实际上说的是它的 Ghost，只要能主动让步和恢复，就可以叫做协程；但协程的实现方式有多种，有的有独立栈，有的没有独立栈，他们都只是协程的壳，不要在意这些细节，嗯。</li>
</ol>
<p>好的，因此 TJ 大神叫它 co，也还是有一定道理的，尽管可能产生一些奇怪的误导……我们来看一下，引入了 co 之后，js 原有的事件循环产生了什么改变呢？</p>
<p>【回头补个图】</p>
<p>好吧，实际上并没有什么改变。因为 promise 本身的实现机制还是回调，所以在 <code>then</code> 的时候就把回调扔给 webAPI 了，等到合适的时机又扔回给事件队列。事件队列中的代码需要等到主栈清空的时候再运行，这时候执行了 <code>iter.next</code> 来恢复生成器——而生成器是没有独立栈的，只有一份保存的上下文；因此只是把生产器的上下文再次加载到栈顶，然后沿着恢复的点继续执行而已。引入生成器之后，事件循环的一切都木有改变！</p>
<h3 id="Node-fibers"><a href="#Node-fibers" class="headerlink" title="Node-fibers"></a>Node-fibers</h3><p>看完了生成器的实现，我们再来看下真·协程的效果。这里以 hack 了 node.js 线程的 <code>node-fibers</code> 为例，看一下真·协程与生产器的区别在何处。</p>
<p>首先，<code>node-fibers</code> 本身仅仅是实现了创造协程的功能以及一些原语，本身并没有类似 co 的异步转同步的语法糖，我们采用相似的方式来包裹一个，为了区别，就叫它 ceo 吧（什么鬼）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Fiber = <span class="built_in">require</span>(<span class="string">'fibers'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ceo</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> def = <span class="built_in">Promise</span>.defer();</span><br><span class="line">    <span class="comment">// 注意这里传入的是回调函数</span></span><br><span class="line">    <span class="keyword">let</span> fiber = <span class="keyword">new</span> Fiber(cb);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复迭代器并带入promise的终值</span></span><br><span class="line">        step(fiber.run(data));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">it</span>) </span>&#123;</span><br><span class="line">        !fiber.started ?</span><br><span class="line">            <span class="comment">// 迭代结束则解决co返回的promise</span></span><br><span class="line">            def.resolve(it.value) :</span><br><span class="line">            <span class="comment">// 否则继续用解决程序解决下一个让步出来的promise</span></span><br><span class="line">            it.then(resolve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve();</span><br><span class="line">    <span class="keyword">return</span> def.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ceo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = Fiber.yield(readFile(<span class="string">'/etc/fstab'</span>));</span><br><span class="line">    <span class="keyword">let</span> f2 = Fiber.yield(readFile(<span class="string">'/etc/shells'</span>));</span><br><span class="line">    <span class="keyword">let</span> sum = f1.toString().length + f2.toString().length;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>观众老爷会说了，这不是差不多么！好像最大的区别就是生成器变成了回调函数，只是少了一个 <code>*</code> 嘛。错！这就是区别！这里最关键的一点在于：没有了生成器，我们可以在任意一层函数里进行让步，这里使用 <code>ceo</code> 包裹的这个回调，是一个真正<strong>独立的执行栈</strong>。在真·协程里，我们可以搞出这样的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ceo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> foo1 = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'read from file1'</span>);</span><br><span class="line">        <span class="keyword">let</span> ret = Fiber.yield(a);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> foo2 = <span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'read from file2'</span>);</span><br><span class="line">        <span class="keyword">let</span> ret = Fiber.yield(b);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> getSum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> f1 = foo1(readFile(<span class="string">'/etc/fstab'</span>));</span><br><span class="line">        <span class="keyword">let</span> f2 = foo2(readFile(<span class="string">'/etc/shells'</span>));</span><br><span class="line">        <span class="keyword">return</span> f1.toString().length + f2.toString().length;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> sum = getSum();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过这个代码可以发现，在第一次让步被恢复的时候，恢复的是一坨执行栈！从栈顶到栈底依次为：<code>foo1</code> =&gt; <code>getSum</code> =&gt; <code>ceo</code> 里的匿名函数；而使用生成器，我们就无法写出这样的程序，因为 <code>yield</code> 原语只能在生产器内部使用——无论什么时候被恢复，都是简单的恢复在生成器内部，所以说生成器是不用开新栈滴。</p>
<p>那么问题就来了，使用了真·协程之后，原先的事件循环模型是否会发生改变呢？是不是主执行栈调用协程的时候，协程就会在自己的栈里跑，而主栈就排空了可以执行异步代码呢？我们来看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> Fiber = <span class="built_in">require</span>(<span class="string">'fibers'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> syncTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span> - now &lt; <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'SyncTask Loaded!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> asyncTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'AsyncTask Loaded!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fiber = Fiber(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    syncTask();</span><br><span class="line">    Fiber.yield();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mainThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    asyncTask();</span><br><span class="line">    fiber.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mainThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// SyncTask Loaded!</span></span><br><span class="line"><span class="comment">// AsyncTask Loaded!</span></span><br></pre></td></tr></table></figure>
<p>我们在主线程执行的时候抛出了一个异步方法，之后在协程里用冗长的同步代码阻塞它，这里我们可以清楚的看到：阻塞任何一个执行中的协程都会阻塞掉主线程！也就是说，即使加入了协程，js 还是可以被认为是单线程的，因为<strong>同一时刻势必只有一个协程在运行</strong>，在协程运行和恢复期间，js 会将当前栈保存，然后用对应协程的栈来填充主的执行栈。<strong>只有所有协程都被挂起或运行结束，才能继续运行异步代码</strong>。</p>
<p>因此，真·协程的引入对事件循环还是造成了一定的影响，可怜的异步代码要等的更久了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近研究了一下 es6 的生成器函数，以及传说中的 co。虽然网上关于协程、co 源码分析的文章数不胜数，但是将其与先前异步实现的事件队列结合起来说明的文章却很难寻觅。之前只知道协程是实现异步的一种方式，那其和之前的各种异步实现究竟有什么本质区别呢？本文将根据协程机制简要探讨一下&lt;strong&gt;引入协程之后的新的事件循环模型&lt;/strong&gt;。由于笔者基础知识不够扎实，所以会先讲述一大堆协程产生的背景和原理，再进行模型变化的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="协程" scheme="http://malcolmyu.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="yield" scheme="http://malcolmyu.github.io/tags/yield/"/>
    
      <category term="event loop" scheme="http://malcolmyu.github.io/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>Git 钩子</title>
    <link href="http://malcolmyu.github.io/2015/10/16/Git-Hooks/"/>
    <id>http://malcolmyu.github.io/2015/10/16/Git-Hooks/</id>
    <published>2015-10-15T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.783Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Git 钩子是在一个 Git 仓库中，在每一次特定事件触发时自动运行的脚本。它允许我们自定义 Git 的内部行为，并在开发的生命周期的关键时间点触发自定义行为。</p>
<a id="more"></a>
<p><img src="./git-tips-hook01.svg" alt="通过链接到版本控制的脚本维护钩子"></p>
<p>Git 钩子通常的使用案例包含支持一个提交策略，根据仓库状态替换项目环境，以及实现连续集成的工作流。但由于脚本是可以任意指定的，所以我们几乎可以使用 Git 的钩子来自动化或优化我们开发工作流的方方面面。</p>
<p>本文的一开始我们先从概念上概述一下 Git 钩子是怎么工作的；之后我们会研究一些使用在本地和服务端仓库的最流行的钩子的使用。</p>
<h2 id="概念概述"><a href="#概念概述" class="headerlink" title="概念概述"></a>概念概述</h2><p>所有的 Git 钩子都是普通的脚本，只是在仓库的特定时机会被 Git 执行。这是得钩子们的安装和配置十分容易。</p>
<p>钩子可以放置在本地或服务端的仓库中，它们仅对各自的仓库行为做出相应并执行。我们会在下文中具体看一下钩子的类型。应用在本地和服务端的钩子的配置会在余下的章节中进行讨论。</p>
<h3 id="安装钩子"><a href="#安装钩子" class="headerlink" title="安装钩子"></a>安装钩子</h3><p>钩子存放在每个 Git 仓库的 <code>.git/hooks</code> 目录。当我们初始化仓库时，Git 会自动生成此目录并在里面放置一些示例脚本。如果你去看一眼 <code>.git/hooks</code> 目录的内容，就会看到如下的文件：</p>
<pre><code>applypatch-msg.sample       pre-push.sample
commit-msg.sample           pre-rebase.sample
post-update.sample          prepare-commit-msg.sample
pre-applypatch.sample       update.sample
pre-commit.sample
</code></pre><p>这里提供了许多可用的钩子，但是 <code>.simple</code> 的后缀使它们都不能默认执行。想要『安装』某一个钩子，我们所需要做的仅仅是移除 <code>.simple</code> 的扩展名。或者如果你动手撸了一个新脚本，那你可以将脚本添加到路径里，并用上面的文件名来命名你的脚本，记得去掉 <code>.simple</code> 后缀哟。</p>
<p>我们安装一个简单的 <code>prepare-commit-msg</code> 钩子作为示例。删除文件的 <code>.simple</code> 后缀，并将下面的内容添加到文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"## 请输入一条有用的提交信息！"</span> &gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure>
<p>钩子文件必须可执行，因此如果我们是徒手撸的脚本，我们需要更改文件的权限。例如，如果想要使 <code>prepare-commit-msg</code> 文件可执行，就需要运行下面的命令：</p>
<pre><code>chmod +x prepare-commit-msg
</code></pre><p>现在我们应该能在每次运行 <code>git commit</code> 的时候看到默认的提交信息（就是上文脚本里的『请输入一条有用的提交信息』）。我们将在 <strong>准备提交信息</strong> 一章仔细研究其工作机制；而现在我们只需要臭美一下：我们已经能自定义 Git 内部的方法啦！</p>
<p>内置的样例脚本是非常有用的参考，它们展示了传递给每个钩子的参数详情（这些参数在钩子之间顺序传递）。</p>
<h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3><p>内置的脚本多是 shell 或 perl 脚本，但是只要我们编写的脚本能够执行，就可以使用任何喜欢的脚本语言。每个脚本文件的 <strong>事务行（shebang line）</strong> 定义了该文件的解释方式。因此想要使用其他的脚本语言，我们只需要改变事务行中解释器的路径就可以了。</p>
<p>举例来说，我们可以在 <code>prepare-commit-msg</code> 文件中编写一个可执行的 Python 脚本来替代 shell 脚本。下面的钩子和上一节的 shell 脚本的执行效果完全一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">commit_msg_filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">with</span> open(commit_msg_filepath, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"## Please include a useful commit message!"</span>)</span><br></pre></td></tr></table></figure>
<p>留心一下文件的第一行指到了 Python 的解释器；同时，我们使用 <code>sys.argv[1]</code> 来代替 <code>$1</code> 来指代传入脚本的第一个参数（我们会在稍后对此进行详述）。</p>
<p>这是 Git 钩子的一个非常给力的特性，使得我们可以使用我们喜欢用的的任何脚本语言来编程。</p>
<h3 id="钩子的作用域"><a href="#钩子的作用域" class="headerlink" title="钩子的作用域"></a>钩子的作用域</h3><p>钩子在存在于每一个 Git 仓库，且当我们运行 <code>git clone</code> 时它们 <strong>不会</strong> 被复制到新仓库中。而且由于钩子是本地的，它们就可以被任何有仓库访问权限的人修改。</p>
<p>这对于一个团队的开发者进行钩子的配置有着重要影响。首先，我们需要找到一种方式来确保钩子在我们的团队成员之间实时更新；其次，我们不能强迫开发者来都用特定的方式来提交，顶多只能鼓励大家这么做。</p>
<p>维护一个开发团队的钩子可是有点棘手，因为 <code>.git/hooks</code> 目录不会随着项目的其他部分复制的，也不会被版本控制。对上面俩问题的最简单的解决方案就是把钩子存在实际的项目目录中（<code>.git</code> 目录之外），这就可以让我们像任何其他版本控制文件一样来编辑钩子。为了安装钩子，我们可以创造一个链接将其链接到 <code>.git/hooks</code>；或者是当有更新的时候，简单的将其复制粘贴到 <code>.git/hooks</code> 目录中。</p>
<p><image src="./git-tips-hook02.svg" alt="在提交创建的过程执行钩子" width="80%"></image></p>

<p>另外，Git 还提供一个<a href="http://git-scm.com/docs/git-init#_template_directory" target="_blank" rel="noopener">模板目录</a>的机制来更加便捷的自动安装钩子。模板目录的所有文件和目录在每次使用 <code>git init</code> 和 <code>git clone</code> 时都会被复制进 <code>.git</code> 目录里。</p>
<p>下文所述的所有本地钩子都可以被仓库管理员替换或删除，这完全取决于每个团队成员是否实际使用钩子。我们最好记住这一点，把 Git 钩子当做一个方便的开发者工具而非一个严格执行的开发政策。</p>
<p>即便如此，我们也可以用服务端钩子来拒绝那些不符合标准的提交。我们会在稍后讨论这一点。</p>
<h2 id="本地钩子"><a href="#本地钩子" class="headerlink" title="本地钩子"></a>本地钩子</h2><p>本地钩子只影响它们所在的仓库。当我们读到这一节时，要记住每位开发者都可以替换其本地的钩子，我们不能使用钩子作为一种强制提交策略。然钩子却使得开发人员更容易坚持既定的开发方针。</p>
<p>在这一节里，我们将展示6个最常用的本地钩子：</p>
<ul>
<li><code>pre-commit</code></li>
<li><code>prepare-commit-msg</code></li>
<li><code>commit-msg</code></li>
<li><code>post-commit</code></li>
<li><code>post-checkout</code></li>
<li><code>pre-rebase</code></li>
</ul>
<p>前四个钩子允许我们在整个提交的生命周期中插入，后面两个允许我们分别为 <code>git checkout</code> 和 <code>git rebase</code> 执行一些额外的行为或者安全检查。</p>
<p>所有的以 <code>pre-</code> 为前缀的钩子都允许我们在后缀的行为 <strong>即将发生</strong> 的时候改变这些行为；而以 <code>post-</code> 为前缀的钩子 <strong>仅用于通知</strong>。</p>
<p>我们也会看到一些实用的技术来解析钩子参数，以及实用底层 Git 命令请求仓库信息。</p>
<h3 id="预提交钩子-Pre-Commit"><a href="#预提交钩子-Pre-Commit" class="headerlink" title="预提交钩子 Pre-Commit"></a>预提交钩子 Pre-Commit</h3><p><code>pre-commit</code> 的脚本在每次运行 <code>git commit</code> 命令时，在 Git 要求开发者填写提交信息和生成提交对象之前执行。我们可以用这个钩子在快照将要被提交的时刻对其进行检查。比方说，我们也许想要在此时运行一些自动测试，以防止本次提交破坏现有功能。</p>
<p><code>pre-commit</code> 脚本没有传入参数，并且以非零状态退出<sup><a href="#note-1">注1</a></sup>会终止整个提交。让我们看一下一个简化的内置 <code>pre-commit</code> 钩子。这个脚本在发现有空白符的错误时会终止整个提交，空白符错误在 <code>git diff-index</code> 命令的 <code>--check</code> 参数里有详细定义（行尾空白符、仅有空白符的行、行首缩进的 tab 后面有空格等格式在默认情况下都会被认为是错误的）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 检测是否为初始提交</span></span><br><span class="line"><span class="keyword">if</span> git rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"pre-commit: About to create a new commit..."</span></span><br><span class="line">    against=HEAD</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"pre-commit: About to create the first commit..."</span></span><br><span class="line">    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用 git diff-index 来检测空白符错误</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"pre-commit: Testing for whitespace errors..."</span></span><br><span class="line"><span class="keyword">if</span> ! git diff-index --check --cached <span class="variable">$against</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"pre-commit: Aborting commit due to whitespace errors"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"pre-commit: No whitespace errors :)"</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>为了使用 <code>git diff-index</code>，我们需要指出需要用来做比较的提交引用。这个引用通常来说是 <code>HEAD</code>，但是在初始提交的时候不存在 <code>HEAD</code> 指针，因此我们的第一个任务就是处理这个边界值。我们使用 <a href="https://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html" target="_blank" rel="noopener"><code>git rev-parse --verify</code></a> 命令，该命令可以检查参数是否是一个可用引用。<code>&gt;/dev/null 2&gt;&amp;1</code> 的部分表示不显示所有 <code>git rev-parse</code> 命令的输出。将 HEAD 或是初始提交的空提交对象存放在 <code>against</code> 变量中来给 <code>git diff-index</code> 使用，而 <code>4b825d...</code> 这个哈希值是一个魔术提交 ID，表示一个空提交。</p>
<p><code>git diff-index --cached</code> 命令将当前暂存区与一个提交进行对比，传入 <code>--check</code> 选项表示我们要求在改动包含空白符错误时给出警告。如果存在空白符错误，我们终止提交并返回退出状态 <code>1</code>，否则我们以 <code>0</code> 退出，且提交工作流正常工作。</p>
<p>这仅仅是 <code>pre-commit</code> 钩子的一个简单例子：使用 Git 命令来在由请求提交引入的更改上运行测试。我们同样可以在 <code>pre-commit</code> 钩子中通过执行其他脚本来做任何想做的事情，例如运行一个第三方测试组件，或者使用 Lint 来检查代码格式。</p>
<h3 id="准备提交信息钩子-Prepare-Commit-Message"><a href="#准备提交信息钩子-Prepare-Commit-Message" class="headerlink" title="准备提交信息钩子 Prepare Commit Message"></a>准备提交信息钩子 Prepare Commit Message</h3><p><code>prepare-commit-msg</code> 钩子在 <code>pre-commit</code> 钩子之后调用，用于给提交的文本编辑器填充提交信息。这是一个替换压缩提交和合并提交时自动生成提交信息的一个好时机。</p>
<p>有 1 到 3 个参数会被传递给 <code>prepare-commit-msg</code> 脚本：</p>
<ol>
<li>包含提交信息的临时文件名。我们通过替换这个文件来更改提交信息。</li>
<li>提交的类型。包含 <code>message</code> （带有 <code>-m</code> 或 <code>-F</code>）、template （带有 <code>-t</code>）、<code>merge</code>（如果提交是一个合并提交）或者 <code>squash</code> （如果提交是从其他提交中合并的）。</li>
<li>相关提交的 SHA1 哈希值。只有带有 <code>-c</code>、<code>-C</code> 或 <code>--amend</code> 的提交会给出这个参数。</li>
</ol>
<p>和 <code>pre-commit</code> 一样，如果脚本以非零状态退出会中止提交。</p>
<p>在上一节我们已经看到了一个简单的编辑提交信息的例子，但是还是让我们看一下一个更加有用的脚本。当使用 issue 来跟踪问题时，惯例是在一个单独的分支里解决一个对应的问题。如果我们在分支名称上包含了 issue 号，我们就可以编写一个 <code>prepare-commit-msg</code> 脚本来在这一分支的每一个提交上都自动导入 issue 号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment">## 收集参数</span></span><br><span class="line">commit_msg_filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    commit_type = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    commit_type = <span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">3</span>:</span><br><span class="line">    commit_hash = sys.argv[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    commit_hash = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"prepare-commit-msg: File: %s\nType: %s\nHash: %s"</span> % (commit_msg_filepath, commit_type, commit_hash)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 找出当前所在分支</span></span><br><span class="line">branch = check_output([<span class="string">'git'</span>, <span class="string">'symbolic-ref'</span>, <span class="string">'--short'</span>, <span class="string">'HEAD'</span>]).strip()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"prepare-commit-msg: On branch '%s'"</span> % branch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果存在 issue 号，则生成带有 issue ## 的提交信息</span></span><br><span class="line"><span class="keyword">if</span> branch.startswith(<span class="string">'issue-'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"prepare-commit-msg: Oh hey, it's an issue branch."</span></span><br><span class="line">    result = re.match(<span class="string">'issue-(.*)'</span>, branch)</span><br><span class="line">    issue_number = result.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(commit_msg_filepath, <span class="string">'r+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">        f.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        f.write(<span class="string">"ISSUE-%s %s"</span> % (issue_number, content))</span><br></pre></td></tr></table></figure>
<p>首先，上面的 <code>prepare-commit-msg</code> 钩子展示了我们怎么获取传入脚本的所有参数。之后，它调用了 <code>git symbolic-ref --short HEAD</code> 来获取当前分支。如果分支名字以 <code>issue-</code> 开头，脚本就会重写提交信息文件的内容，在开头的一行引入 issue 号。因此，如果你的分支名是 <code>issue-224</code>，运行脚本就会生成下列提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ISSUE-224 </span><br><span class="line"></span><br><span class="line"><span class="comment">## Please enter the commit message for your changes. Lines starting </span></span><br><span class="line"><span class="comment">## with '#' will be ignored, and an empty message aborts the commit. </span></span><br><span class="line"><span class="comment">## On branch issue-224 </span></span><br><span class="line"><span class="comment">## Changes to be committed: </span></span><br><span class="line"><span class="comment">##   modified:   test.txt</span></span><br></pre></td></tr></table></figure>
<p>在使用 <code>pre-commit-msg</code> 钩子时，需要记住的一点是在使用者通过 <code>-m</code> 参数运行 <code>git commit</code> 命令时本钩子依然会被执行。这就意味着在使用 <code>-m</code> 输入提交信息的时候，上面的脚本会在提交信息里直接加入 <code>ISSUE-[#]</code> 的内容，用户也没法编辑它。我们可以通过判断第二个参数（<code>commit_type</code>）是否等于 <code>message</code> 的方式来处理这个特殊情况。</p>
<p>然后，在不带 <code>-m</code> 参数的情况下，<code>prepare-commit-msg</code> 钩子也会允许用户编辑自动生成的信息，所以这更多的是一个提供便利的脚本而非强制执行的提交政策。如果想要强制性的政策，我们需要在下一节讨论的 <code>commit-msg</code> 钩子。</p>
<h3 id="提交信息钩子-Commit-Message"><a href="#提交信息钩子-Commit-Message" class="headerlink" title="提交信息钩子 Commit Message"></a>提交信息钩子 Commit Message</h3><p><code>commit-msg</code> 钩子与 <code>prepare-commit-msg</code> 很相似，但是这个钩子在用户输入提交信息 <strong>之后</strong> 调用。这个钩子适宜用于警告开发者他们的提交信息不符合我们团队的标准。</p>
<p>传递给这个钩子的唯一参数就是包含提交信息的临时文件名，如果钩子不喜欢用户输入的信息，它就会将改文件替换（与 <code>prepare-commit-msg</code> 的行为一样）或者以非零状态退出从而终止整个提交。</p>
<p>举例来说，下面的脚本检查并确保用户不能删除上一节所述的 <code>prepare-commit-msg</code> 钩子自动生成的 issue 号 <code>ISSUE-[#]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment">## 收集参数</span></span><br><span class="line">commit_msg_filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 找出当前所在分支</span></span><br><span class="line">branch = check_output([<span class="string">'git'</span>, <span class="string">'symbolic-ref'</span>, <span class="string">'--short'</span>, <span class="string">'HEAD'</span>]).strip()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"commit-msg: On branch '%s'"</span> % branch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果我们在 issue 分支上，进行提交信息的检查</span></span><br><span class="line"><span class="keyword">if</span> branch.startswith(<span class="string">'issue-'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"commit-msg: Oh hey, it's an issue branch."</span></span><br><span class="line">    result = re.match(<span class="string">'issue-(.*)'</span>, branch)</span><br><span class="line">    issue_number = result.group(<span class="number">1</span>)</span><br><span class="line">    required_message = <span class="string">"ISSUE-%s"</span> % issue_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(commit_msg_filepath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(required_message):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"commit-msg: ERROR! The commit message must start with '%s'"</span> % required_message</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>由于用户每创建一个提交时，该脚本就会被调用，所以我们还是应该避免对提交信息进行过多的检查。如果在有新提交时，需要通知其他服务，那么我们应该使用下面的 <code>post-commit</code> 钩子。</p>
<h3 id="提交后钩子-Post-Commit"><a href="#提交后钩子-Post-Commit" class="headerlink" title="提交后钩子 Post-Commit"></a>提交后钩子 Post-Commit</h3><p><code>post-commit</code> 钩子在 <code>commit-msg</code> 钩子之后立即出发。其可以改变 <code>git commit</code> 命令的输出，因此主要被用作通知提醒。</p>
<p>本脚本没有参数传入，且它的退出状态也不会影响到提交。对于大多数 <code>post-commit</code> 钩子来说，我们都希望能够访问刚刚创建的那个提交。我们可以使用 <code>git rev-parse HEAD</code> 来获取最新提交的 SHA1 哈希值，或者使用 <code>git log -l</code> 来获取它的所有信息。</p>
<p>举个例子，如果我们想要在每次提交快照时给我们的领导发个邮件（但如果这样做可能会被领导揍一顿……），就可以添加下面的 <code>post-commit</code> 钩子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment">## Get the git log --stat entry of the new commit</span></span><br><span class="line">log = check_output([<span class="string">'git'</span>, <span class="string">'log'</span>, <span class="string">'-1'</span>, <span class="string">'--stat'</span>, <span class="string">'HEAD'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## Create a plaintext email message</span></span><br><span class="line">msg = MIMEText(<span class="string">"Look, I'm actually doing some work:\n\n%s"</span> % log)</span><br><span class="line"></span><br><span class="line">msg[<span class="string">'Subject'</span>] = <span class="string">'Git post-commit hook notification'</span></span><br><span class="line">msg[<span class="string">'From'</span>] = <span class="string">'mary@example.com'</span></span><br><span class="line">msg[<span class="string">'To'</span>] = <span class="string">'boss@example.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Send the message</span></span><br><span class="line">SMTP_SERVER = <span class="string">'smtp.example.com'</span></span><br><span class="line">SMTP_PORT = <span class="number">587</span></span><br><span class="line"></span><br><span class="line">session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)</span><br><span class="line">session.ehlo()</span><br><span class="line">session.starttls()</span><br><span class="line">session.ehlo()</span><br><span class="line">session.login(msg[<span class="string">'From'</span>], <span class="string">'secretPassword'</span>)</span><br><span class="line"></span><br><span class="line">session.sendmail(msg[<span class="string">'From'</span>], msg[<span class="string">'To'</span>], msg.as_string())</span><br><span class="line">session.quit()</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>post-commit</code> 来触发一个本地 <strong>持续集成系统</strong> <sup><a href="#note-2">注2</a></sup>，但是大多数时间我们会把这件事放在 <code>post-receive</code> 钩子里。这个钩子跑在服务端而非本地，且 <strong>每当</strong> 有开发者提交代码的时候都会运行，因此这里更加适合部署我们的持续集成系统。</p>
<h3 id="切换后钩子-Post-Checkout"><a href="#切换后钩子-Post-Checkout" class="headerlink" title="切换后钩子 Post-Checkout"></a>切换后钩子 Post-Checkout</h3><p><code>post-checkout</code> 钩子工作机制与 <code>post-commit</code> 钩子很像，其触发时机是每次我们使用 <code>git checkout</code> 切换到一个新引用上。它大可用在清理你工作目录生成的文件，尽管这么用可能会让人困惑。</p>
<p>这个钩子接受三个参数，它的退出状态不会影响到 <code>git checkout</code> 命令。</p>
<ol>
<li>之前 <code>HEAD</code> 的引用</li>
<li>新 <code>HEAD</code> 的引用</li>
<li>一个标志，告诉我们切换的是分支还是文件，分支是 1，文件是 0。</li>
</ol>
<p>通常 Python 开发者们都会遇到一个蛋疼的问题：在切换分支的时候，之前生成的各种 <code>.pyc</code> 文件依然留在工作区内。解释器有时使用 <code>.pyc</code> 而非 <code>.py</code> 作为源文件。为了避免混乱，我们可以使用下面的钩子在每次切换新分支的时候清理所有的 <code>.pyc</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"></span><br><span class="line"><span class="comment">## Collect the parameters</span></span><br><span class="line">previous_head = sys.argv[<span class="number">1</span>]</span><br><span class="line">new_head = sys.argv[<span class="number">2</span>]</span><br><span class="line">is_branch_checkout = sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_branch_checkout == <span class="string">"0"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"post-checkout: This is a file checkout. Nothing to do."</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"post-checkout: Deleting all '.pyc' files in working directory"</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'.'</span>):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">        ext = os.path.splitext(filename)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">'.pyc'</span>:</span><br><span class="line">            os.unlink(os.path.join(root, filename))</span><br></pre></td></tr></table></figure>
<p>对于钩子脚本来说，当前工作目录永远被设定为仓库根目录，因此 <code>os.walk(&#39;.&#39;)</code> 可以遍历仓库中的每一个文件。然后我们就可以删掉哪些后缀名是 <code>.pyc</code> 的文件啦。</p>
<p>我们也可以使用 <code>post-checkout</code> 钩子基于已经切换到的分支来改变工作目录。例如我们可能使用一个叫做 <code>plugins</code> 的分支来存储核心代码之外的各种插件。如果这些插件体积不小，且其他的分支并不需要，我们就可以仅在切换到 <code>plugins</code> 分支时才有选择的进行插件构建。</p>
<h3 id="预衍合钩子-Pre-Rebase"><a href="#预衍合钩子-Pre-Rebase" class="headerlink" title="预衍合钩子 Pre-Rebase"></a>预衍合钩子 Pre-Rebase</h3><p><code>pre-rebase</code> 钩子在使用 <code>git rebase</code> 命令做任何改变之前触发，本钩子可以很好的确保一些糟糕情况的发生。</p>
<p>钩子有两个参数：分岔起点的上游分支和正在被衍合的分支。当衍合当前分支时，第二个参数为空。脚本以非零状态退出会终止衍合。</p>
<p>例如，如果我们在项目中完全不允许衍合，可以使用下面的钩子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Disallow all rebasing</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"pre-rebase: Rebasing is dangerous. Don't do it."</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure>
<p>现在每当我们运行 <code>git rebase</code> 都会看到下面的信息：</p>
<pre><code>pre-rebase: Rebasing is dangerous. Don&apos;t do it.
The pre-rebase hook refused to rebase.
</code></pre><p>如果想看更深入一点的例子，推荐研究自带的 <code>pre-rebase.sample</code> 脚本。这个脚本更加睿智一点，会在特定的情况下拒绝衍合。它会严查你准备衍合的分支是否已经合并到主线分支上。如果已合并，再进行衍合就会产生混乱，因此脚本就会拒绝衍合。</p>
<h2 id="服务端钩子"><a href="#服务端钩子" class="headerlink" title="服务端钩子"></a>服务端钩子</h2><p>服务端钩子和本地钩子的工作机制相同，区别仅在于其部署在服务端仓库（例如中央仓库或开发者的公共仓库）。由于部署在这种官方仓库，一些服务端钩子可以作为一种强制政策来拒绝一些特定提交。</p>
<p>下文中我们将讨论三种服务端钩子：</p>
<ul>
<li><code>pre-receive</code></li>
<li><code>update</code></li>
<li><code>post-receive</code></li>
</ul>
<p>所有的这些钩子都是为了让我们能够在 Git 推送的不同阶段做出反应。</p>
<p>服务端钩子的输出会显示在客户端控制台上，因此将信息返回给开发者十分容易。但是我们应该记住这些脚本在结束执行之前不会返回终端的控制权，因此我们应该慎重处理那些运行时间较长的操作。</p>
<h3 id="预接收钩子-Pre-Receive"><a href="#预接收钩子-Pre-Receive" class="headerlink" title="预接收钩子 Pre-Receive"></a>预接收钩子 Pre-Receive</h3><p><code>pre-receive</code> 钩子在每次有用户执行 <code>git push</code> 来推送提交到仓库中时都会被执行。其仅能存在于那些作为推送目标的 <strong>远端仓库</strong>，而非在原始仓库。</p>
<p>钩子在每次引用被更新之前都会运行，因此适合按照我们的意愿做成强制执行的开发政策。如果我们不希望某人进行推送，或者不喜欢某些提交信息的格式和提交内容，我们都可以使用这个钩子拒绝推送。尽管我们不能阻止开发者搞出一些乱七八糟的提交，但至少能使用 <code>pre-receive</code> 阻挡这些难看的提交进入中央仓库。</p>
<p>本脚本不传入参数，但是每个正在被推送的引用都通过标准输入的方式分行传入脚本，格式如下：</p>
<pre><code>&lt;old-value&gt; &lt;new-value&gt; &lt;ref-name&gt;
</code></pre><p>我们可以通过最基本的 <code>pre-receive</code> 脚本来看到本钩子是怎么工作的，下面的脚本仅仅是读入了引用内容并进行了输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"></span><br><span class="line"><span class="comment">## Read in each ref that the user is trying to update</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"pre-receive: Trying to push ref: %s"</span> % line</span><br><span class="line"></span><br><span class="line"><span class="comment">## Abort the push</span></span><br><span class="line"><span class="comment">## sys.exit(1)</span></span><br></pre></td></tr></table></figure>
<p>不过，这里还是跟其他的钩子略有不同，因为信息是通过标准输入而非命令行参数传入的。当将本钩子防止到远端仓库的 <code>.git/hooks</code> 中，并对 <code>master</code> 分支进行推送时，我们就会看到如下信息出现在控制台上：</p>
<pre><code>b6b36c697eb2d24302f89aa22d9170dfe609855b 85baa88c22b52ddd24d71f05db31f4e46d579095 refs/heads/master
</code></pre><p>我们可以使用这些 SHA1 哈希值和一些底层 Git 命令，来检查即将生成的改动，通常有以下的用法：</p>
<ul>
<li>拒绝包含衍合了上游分支的提交；</li>
<li>阻止非快进合并；</li>
<li>检查用户是否有权限来进行某些修改（多用于中央化的 Git 工作流）</li>
</ul>
<p>如果多个引用被提交，返回非零状态会取消全部的引用。如果我们想按照具体提交来接受或拒绝分支，就需要使用 <code>update</code> 钩子。</p>
<h3 id="更新钩子-Update"><a href="#更新钩子-Update" class="headerlink" title="更新钩子 Update"></a>更新钩子 Update</h3><p><code>update</code> 钩子在 <code>pre-receive</code> 之后被调用，工作原理差不多。其也会在所有东西被真实提交之前执行，但却分别为每一个推送的引用而调用。意思是说如果用户尝试推送四个分支，<code>update</code> 钩子就会尝试执行四次。与 <code>pre-receive</code> 不同的是，该钩子不需要读入标准输入，想法其接受如下的三个参数：</p>
<ul>
<li>正在更新的引用名称；</li>
<li>分支引用中存储的旧提交对象；</li>
<li>分支引用中存储的新提交对象。</li>
</ul>
<p>这与传递给 <code>pre-receive</code> 钩子的信息相同，但是由于 <code>update</code> 在每一个分支更新时都会被触发，我们可以拒绝一部分分支而允许其他的分支提交。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">branch = sys.argv[<span class="number">1</span>]</span><br><span class="line">old_commit = sys.argv[<span class="number">2</span>]</span><br><span class="line">new_commit = sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Moving '%s' from %s to %s"</span> % (branch, old_commit, new_commit)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Abort pushing only this branch</span></span><br><span class="line"><span class="comment">## sys.exit(1)</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>update</code> 钩子仅仅输出了分支名和新旧提交哈希值。当给远端的仓库推送多个分支时，我们可以看到每个分支都执行了一次 <code>print</code> 语句。</p>
<h3 id="接受后钩子-Post-Receive"><a href="#接受后钩子-Post-Receive" class="headerlink" title="接受后钩子 Post-Receive"></a>接受后钩子 Post-Receive</h3><p><code>post-receive</code> 钩子在成功推送之后调用，适宜用作进行消息提示。对许多工作流来说，本钩子比 <code>post-commit</code> 更适合触发通知，因为钩子放在公共服务器上改起来方便，分发给每一个用户放在本地机器上改都没法改。在持续集成系统里，经常使用 <code>post-receive</code> 钩子给其他开发者发邮件。</p>
<p>本钩子没有参数，但是会从标准输入接入与 <code>pre-receive</code> 一样的输入参数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文我们学习了如何使用 Git 钩子改变内部行为以及项目中特定事件触发时进行通知。钩子就是放置在 <code>.git/hooks</code> 路径下的普通脚本，这使得他们易于安装和制定。</p>
<p>我们也研究了一些最普通的本地及服务端钩子，这使得我们可以在整个开发的生命周期中插入操作。我们现在知道了如何在提交创建、推送过程的每一步中执行自定义操作。只需要懂一点脚本知识，我们就可以对 Git 仓库做很多想做的事情。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><b id="note-1">注1：</b>exit 命令一般用于结束一个脚本，能返回一个值给父进程，执行成功的话这个值会是 0，因此非零退出表示脚本执行失败。如果一个脚本以不带参数的 exit 命令结束，脚本的退出状态码将会是执行 exit 命令前的最后一个命令的退出码（用 <code>$?</code> 表示），详见：<a href="http://shouce.jb51.net/shell/exit-status.html" target="_blank" rel="noopener">退出和退出状态</a>。</li>
<li><b id="note-2">注2：</b>持续集成是一种软件项目管理方法，依据资产库（源码，类库等）的变更自动完成编译、测试、部署和反馈，详见阮老师的博文：<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">什么是持续集成系统？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 钩子是在一个 Git 仓库中，在每一次特定事件触发时自动运行的脚本。它允许我们自定义 Git 的内部行为，并在开发的生命周期的关键时间点触发自定义行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Git 魔导之路" scheme="http://malcolmyu.github.io/categories/Git-%E9%AD%94%E5%AF%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Git" scheme="http://malcolmyu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>协作同步</title>
    <link href="http://malcolmyu.github.io/2015/08/01/Collaborating-Syncing/"/>
    <id>http://malcolmyu.github.io/2015/08/01/Collaborating-Syncing/</id>
    <published>2015-07-31T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.780Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>SVN 使用一个单独的中心仓库以作为开发者的通信枢纽，其协作的方式是开发者的工作副本与中央仓库互相发送变更记录。这与 Git 的协作模式有所不同，Git 中每个开发者都拥有仓库的副本，以及完整的本地历史和分支结构。用户通常只需要提供一系列的提交而不是单个的变更记录。Git 允许我们在仓库之间共享整个分支，而不是单单的从工作副本提交一个变更记录到中央仓库去。</p>
<p>下面介绍的命令可以帮助我们管理与其他仓库的连接：我们可以使用“推送”分支的方式将本地历史发布到其他仓库，也可以使用“拉取”分支的方式将别人贡献的代码获取到本地。</p>
<a id="more"></a>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p><code>git remote</code> 命令让我们可以创建、查看和删除与其他仓库的链接。远端链接不是直接连到别的仓库，它更像是一个书签一样的快捷方式：它并没有提供与其他仓库的实时连接，而是提供了一个方便好记的别名以指代那些不那么方便的 URL。</p>
<p>比如下图就展示了从我们本地仓库链接到中央仓库和其他开发者仓库的两个链接。我们可以不用 URLs 全称来表示，而只用给其他的 Git 命令传递诸如 origin 和 john 这样的缩写就行。</p>
<p><img src="./git-coll-sync01.svg" alt="git remote 示例"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>
<p>展示你与其他仓库之间的全部远端链接（仅有别名）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>与上条命令相同，不过带上了每个链接的 URL。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>创建一个连接到新远端仓库的链接。添加链接之后，我们就可以在其他的 Git 命令中方便地使用 <code>&lt;name&gt;</code> 作为指代 url 的简写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>删除名为 <code>&lt;name&gt;</code> 的远端链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
<p>将一个名为 <code>&lt;old-name&gt;</code> 的链接重命名为 <code>&lt;new-name&gt;</code></p>
<h3 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h3><p>Git 的设计初衷是给每一位开发者一个完整而独立的开发环境，这就意味着    信息不能自动的在库间传递。相反，开发者需要手动的将上游提交拉取到本地，或者手动的将本地提交推送会中央仓库。<code>git remote</code> 命令仅仅就是一个给那些带有“共享”性质的 Git 命令（<strong>译者注：</strong>如本文后面讲解的 <code>push</code> <code>pull</code> 命令等）传递 URL 的一个便捷方式。</p>
<h4 id="origin-远端"><a href="#origin-远端" class="headerlink" title="origin 远端"></a>origin 远端</h4><p>当你使用 <code>git clone</code> 命令克隆一个仓库时，Git 会自动创建一个叫做 origin 的远程链接指向被克隆的仓库。这对开发者来说十分有益：当我们在本地创建一个中央仓库的副本时，可以便捷的推动本地提交或拉取远端修改。这也是大多数基于 Git 的项目管中央仓库叫“origin”的原因。</p>
<h4 id="仓库-URLs"><a href="#仓库-URLs" class="headerlink" title="仓库 URLs"></a>仓库 URLs</h4><p>Git 提供了许多方式以作为远端仓库的引用。两个最常用的方式就是通过 HTTP 协议和 SSH 协议。HTTP 是对仓库进行匿名且只有只读权限的访问的一条便捷方式，例如：</p>
<blockquote>
<p><a href="http://host/path/to/repo.git" target="_blank" rel="noopener">http://host/path/to/repo.git</a></p>
</blockquote>
<p>但是通常情况下给一个 HTTP 地址推送提交是不太可能的（我们应该也不会允许匿名用户推送提交）。我们应该使用 SSH 协议以获取读写权限：</p>
<blockquote>
<p>ssh://user@host/path/to/repo.git</p>
</blockquote>
<p>我们在主机上需要有一个可用的 SSH 账号，除此之外，Git 也支持带有权限校验的访问（SSH 自带的）。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>除了 origin 以外，连接同事的仓库也是十分方便的。例如你的好基友 John 维护着一个地址是 <code>dev.example.com/john.git</code> 公用仓库，你就可以这样添加一个链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add john http://dev.example.com/john.git</span><br></pre></td></tr></table></figure>
<p>通过这种到个人开发者仓库的连接方式，使中央仓库之外的协作成为可能。这对于小团队开发大项目来说十分有用。</p>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p><code>git fetch</code> 命令从远端仓库将提交导入到本地。导入的提交已然存储在远端分支而非我们工作的本地分支。这让我们在将远端提交整合到本地之前可以有机会审核一下代码。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure>
<p>拉取该仓库的全部分支，这一操作也会把所有必要的提交和文件都下载下来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>和上一命令类似，但仅拉取特定的分支。</p>
<h3 id="详述-1"><a href="#详述-1" class="headerlink" title="详述"></a>详述</h3><p>当我们想查看其他人的工作时，可以采用 fetch 操作。既然 fetch 的参数代表着一个远端分支，那这一操作就对本地开发工作完全没有影响。fetch 为我们提供了一种不整合、先审核的安全的审核提交的方式。这有点像 svn update，它让我们看到中央仓库的历史情况，却不强制我们实际将更改并入本地仓库。</p>
<h4 id="远端分支"><a href="#远端分支" class="headerlink" title="远端分支"></a>远端分支</h4><p>远端分支和本地分支很像，只不过远端包含了来自其他人仓库的提交。我们可以像查看本地分支一样查看远端分支，但是这会使我们的工程进入“分离头指针”的状态（正如检出到一个旧有提交的状态一样），我们可以将其当做一个只读的分支。想要查看远端分支，我们只需要给 <code>git branch</code> 命令加上一个 <code>-r</code> 参数。远端的分支会以远端的别名作为前缀，因此我们不会把它们和本地分支弄混。下面这个例子就展示了我们在获取 origin 的远端时可能看到的分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br><span class="line"><span class="comment">## origin/master</span></span><br><span class="line"><span class="comment">## origin/develop</span></span><br><span class="line"><span class="comment">## origin/some-feature</span></span><br></pre></td></tr></table></figure>
<p>然后我们可以通过 <code>git checkout</code> 和 <code>git log</code> 的命令来检视这些分支。如果我们觉得一个远端分支的更改靠谱，就可以使用 <code>git merge</code> 命令将它整合到一个本地分支。与 SVN 不同的是，同步远端分支到本地的操作是 fetch 和 merge 两个过程。但 Git 却可以方便的使用 <code>git pull</code> 命令来完成这两个过程。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>这一示例展示了同步中央仓库的 <code>master</code> 分支到本地仓库这一典型工作流程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>
<p>这一步会展示已下载的分支们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a1e8fb5..45e66a4 master -&gt; origin/master</span><br><span class="line">a1e8fb5..9e8ab1c develop -&gt; origin/develop</span><br><span class="line">* [new branch] some-feature -&gt; origin/some-feature</span><br></pre></td></tr></table></figure>
<p>从新的远端分支获取的提交们在下表中以方块显示，而之前在本地的提交以圆圈显示。如图所示， <code>git fetch</code> 使我们访问到另一个仓库的全部分支结构。</p>
<p><img src="./git-coll-sync02.svg" alt="git fetch 获取远端分支结构">    </p>
<p>想查看上游的 master 分支添加了哪些提交，我们可以使用 <code>git log</code> 命令，并添加 <code>origin/master</code> 的过滤器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline master..origin/master</span><br></pre></td></tr></table></figure>
<p>使用如下的命令可以将我们认可的分支合并到我们本地的 <code>master</code> 分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git <span class="built_in">log</span> origin/master</span><br></pre></td></tr></table></figure>
<p>之后我们便可以使用 <code>git merge</code> 命令合并 <code>origin/master</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>
<p>现在 origin/master 和本地的 master 分支都指向了同一提交，我们已经完成了与上游开发内容的同步。</p>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>将上游更改合并到本地仓库在基于 Git 的协作工作流中是一个常见的操作。我们已经知道如何用 <code>git fetch</code> 和 <code>git merge</code> 来完成这一操作，但是 <code>git pull</code> 将这两部操作整合为一个命令。    </p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull &lt;remote&gt;</span><br></pre></td></tr></table></figure>
<p>这一命令表示获取制定的当前分支的远端副本并将其立即合并到本地副本中。这一命令与先 <code>git fetch &lt;remote&gt;</code> 然后 <code>git merge origin/&lt;current-branch&gt;</code> 效用相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --rebase &lt;remote&gt;</span><br></pre></td></tr></table></figure>
<p>和上一命令相同，不过不是使用 <code>git merge</code> 来整合远端分支，而是使用 <code>git rebase</code>。    </p>
<h3 id="详述-2"><a href="#详述-2" class="headerlink" title="详述"></a>详述</h3><p>我们可以把 <code>git pull</code> 理解成 <code>svn update</code> 的 Git 版本。这是一个将上游更改同步到本地仓库的快捷方式。下面的图解释了 pull 过程的每一步骤。</p>
<p><img src="./git-coll-sync03.svg" alt="git pull 过程"></p>
<p>本来我们以为我们本地的仓库处于已同步状态，但是呢通过 <code>git fetch</code> 我们发现 origin 上的 master 在我们上次检查之后又有新的提交。于是 <code>git merge</code> 命令直接将远端 master 上的新内容整合到了本地。</p>
<h4 id="拉取和衍合"><a href="#拉取和衍合" class="headerlink" title="拉取和衍合"></a>拉取和衍合</h4><p><code>--rebase</code> 参数可以用组织不必要提交的方式来保证线性提交历史。相比较合并，许多开发者更喜欢衍合一些，因为衍合的意思就像：“我想要将我的更改放在其他人的更改之上”。由于这个原因，在 <code>git pull</code> 时使用 <code>--rebase</code> 参数比不带衍合参数更像 <code>svn update</code> 一些。</p>
<p>实际上，使用 <code>--rebase</code> 参数拉取实在是太常用了，因此都有一个专用的配置项来配置它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global branch.autosetuprebase always</span><br></pre></td></tr></table></figure>
<p>运行了上面的命令之后，所有的 <code>git pull</code> 命令就会自动通过 <code>git rebase</code> 而非 <code>git merge</code> 来进行分支整合。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>下例展示了如何从中央仓库的 master 分支上同步代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull --rebase origin</span><br></pre></td></tr></table></figure>
<p>这就便捷的将我们本地的更改放在了其他人提交的代码的顶部。</p>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>推送就是我们将本地仓库的提交传送到远端仓库的方法。它是 <code>git fetch</code> 的反面：获取将提交引入本地分支，推送将提交导出到远端分支。推送本身可能会导致重写提交，因此我们在使用时还是要多加注意。这些内容下面会进行详细的讨论。</p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>该命令表示将特定的分支 <code>&lt;branch&gt;</code> 中的所有必要的提交和内部对象推送到 <code>&lt;remote&gt;</code> 上。这一操作给目标仓库创造了一个本地分支。为了防止我们重写提交，当目标仓库处在<strong>非快进合并状态</strong><sup><a href="#note-1">注1</a></sup>时，Git 是不允许我们提交的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; --force</span><br></pre></td></tr></table></figure>
<p>和上面的命令相似，只不过即使没有处在快进合并状态时也可以强制提交。<strong>不要</strong>使用 <code>--force</code> 参数，除非你确切的知道自己在干啥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; --all</span><br></pre></td></tr></table></figure>
<p>将所有本地分支提交到指定远端上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; --tags</span><br></pre></td></tr></table></figure>
<p>在使用 <code>--all</code> 参数时也不会自动把<strong>标签</strong><sup><a href="#note-2">注2</a></sup>提交上去的。 <code>--tags</code> 参数会将我们本地所有的标签提交到远端仓库中。</p>
<h3 id="详述-3"><a href="#详述-3" class="headerlink" title="详述"></a>详述</h3><p><code>git push</code> 命令最常见的使用场景就是将本地的更改推送到中央仓库中。当我们已经积攒了一些本地提交并准备将其与团队中的其他同事分享这些提交时，我们可以先使用交互式的衍合修整我们的提交，然后将它们推送到中央仓库。</p>
<p><img src="./git-coll-sync04.svg" alt="推送提交图解"></p>
<p>上图展示了当我们运行 <code>git push origin master</code> 时本地 <code>master</code> 分支和中央仓库的 <code>master</code> 分支之间发生了什么。注意 <code>git push</code> 命令在本质上与在远端仓库运行 <code>git merge master</code> 所产生的效果一致。</p>
<h4 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h4><p>当中央仓库处在非快进合并状态时，Git 会阻止提交以防止我们覆盖中央仓库的历史记录。因此当远端历史与本地历史分离时，我们需要先拉取远端分支将其合并到本地上，然后再尝试推送。这与 SVN 在我们使用 <code>svn update</code> 提交变更集合之前先让我们与中央仓库同步的做法是一致的。</p>
<p><code>--force</code> 参数改变了此行为而使远端仓库的分支匹配我们本地的分支，并会删除我们上次提交之后尚有分支的任何更改。我们唯一应该使用强制推送的场景是当我们意识到我们之前推送的提交是有问题的，并使用 <code>git commit --amend</code> 或交互式衍合来更改了这一提交。然而我们在进行强制推送之前，也必须确认这期间没有同事拉取了我们之前的提交。</p>
<h4 id="只推送到裸仓库"><a href="#只推送到裸仓库" class="headerlink" title="只推送到裸仓库"></a>只推送到裸仓库</h4><p>再就是我们应该仅往使用 <code>--bare</code> 参数创建的裸仓库进行推送。由于推送会弄乱远端分支结构，因此千万不要推送到其他开发者的仓库去。但是由于裸仓库没有工作目录，因此并不会扰乱其他人的开发。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>下例展示了一种将本地开发推送到中央仓库的一种标准方法。首先，要获取中央仓库的副本并将更改衍合到顶部，以确保我们本地 <code>master</code> 分支是<strong>最新的（up-to-date）</strong>。使用交互式衍也是在推送提交前进行清理的一个好选择。之后，使用 <code>git push</code> 命令将所有本地 <code>master</code> 分支上的提交推送到中央仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git fetch origin master</span><br><span class="line">git rebase -i origin/master</span><br><span class="line"><span class="comment">## 进行压缩提交，修改提交信息等工作</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>由于我们已经确保本地 <code>master</code> 分支是最新的，因此推送会导致一个快进合并，使用 <code>git push</code> 命令也不必抱怨哪些之前提到的非快进合并状态的问题。</p>
<hr>
<p><strong>译注</strong></p>
<ul>
<li><b id="note-1">注1</b> <strong>非快进合并状态（non-fast-forward merge）</strong>：与快进状态相对立，按 Git Pro 书上的<a href="http://iissnan.com/progit/html/zh/ch3_2.html" target="_blank" rel="noopener">解释</a>：</li>
</ul>
<blockquote>
<p>如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）</p>
</blockquote>
<p>因此非快进合并状态即是指当要合并的分支不是在当前分支的上游，提交出现分岔的状态。</p>
<ul>
<li><b id="note-2">注2</b> <strong>标签</strong>：再发布版本的时候打上标签标记，是 VCS 的通用方法。详见 Git Pro <a href="http://iissnan.com/progit/html/zh/ch2_6.html" target="_blank" rel="noopener">打标签</a>一章。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVN 使用一个单独的中心仓库以作为开发者的通信枢纽，其协作的方式是开发者的工作副本与中央仓库互相发送变更记录。这与 Git 的协作模式有所不同，Git 中每个开发者都拥有仓库的副本，以及完整的本地历史和分支结构。用户通常只需要提供一系列的提交而不是单个的变更记录。Git 允许我们在仓库之间共享整个分支，而不是单单的从工作副本提交一个变更记录到中央仓库去。&lt;/p&gt;
&lt;p&gt;下面介绍的命令可以帮助我们管理与其他仓库的连接：我们可以使用“推送”分支的方式将本地历史发布到其他仓库，也可以使用“拉取”分支的方式将别人贡献的代码获取到本地。&lt;/p&gt;
    
    </summary>
    
      <category term="Git 魔导之路" scheme="http://malcolmyu.github.io/categories/Git-%E9%AD%94%E5%AF%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Git" scheme="http://malcolmyu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Promise A+ 规范</title>
    <link href="http://malcolmyu.github.io/2015/06/12/Promises-A-Plus/"/>
    <id>http://malcolmyu.github.io/2015/06/12/Promises-A-Plus/</id>
    <published>2015-06-11T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>英文原文：<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a><br>图灵译文：<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">【翻译】Promises/A+规范</a></p>
<p><strong>译者序：</strong>一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。</p>
<a id="more"></a>
<p><strong>一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。</strong></p>
<hr>
<p><strong>译文术语</strong></p>
<ul>
<li><strong>解决（fulfill）</strong>：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 <code>fulfill</code> 来表示解决，但在后世的 promise 实现多以 <code>resolve</code> 来指代之。</li>
<li><strong>拒绝（reject）</strong>：指一个 promise 失败时进行的一系列操作。</li>
<li><strong>终值（eventual value）</strong>：所谓终值，指的是 promise 被<strong>解决</strong>时传递给解决回调的值，由于 promise 有<strong>一次性</strong>的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>
<li><strong>据因（reason）</strong>：也就是拒绝原因，指在 promise 被<strong>拒绝</strong>时传递给拒绝回调的值。</li>
</ul>
<hr>
<p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 <code>then</code> 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。</p>
<p>本规范详细列出了 <code>then</code> 方法的执行过程，所有遵循 Promises/A+ 规范实现的 promise 均可以本标准作为参照基础来实施 <code>then</code> 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。</p>
<p>从历史上说，本规范实际上是把之前 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">Promise/A 规范</a> 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。</p>
<p>最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 <code>then</code> 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><hr>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>promise 是一个拥有 <code>then</code> 方法的对象或函数，其行为符合本规范；</p>
<h3 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h3><p>是一个定义了 <code>then</code> 方法的对象或函数，文中译作“拥有 <code>then</code> 方法”；</p>
<h3 id="值（value）"><a href="#值（value）" class="headerlink" title="值（value）"></a>值（value）</h3><p>指任何 JavaScript 的合法值（包括 <code>undefined</code> , thenable 和 promise）；</p>
<h3 id="异常（exception）"><a href="#异常（exception）" class="headerlink" title="异常（exception）"></a>异常（exception）</h3><p>是使用 <code>throw</code> 语句抛出的一个值。</p>
<h3 id="据因（reason）"><a href="#据因（reason）" class="headerlink" title="据因（reason）"></a>据因（reason）</h3><p>表示一个 promise 的拒绝原因。</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><hr>
<h3 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h3><p>一个 Promise 的当前状态必须为以下三种状态中的一种：<strong>等待态（Pending）</strong>、<strong>执行态（Fulfilled）</strong>和<strong>拒绝态（Rejected）</strong>。</p>
<h4 id="等待态（Pending）"><a href="#等待态（Pending）" class="headerlink" title="等待态（Pending）"></a>等待态（Pending）</h4><p>处于等待态时，promise 需满足以下条件：</p>
<ul>
<li>可以迁移至执行态或拒绝态</li>
</ul>
<h4 id="执行态（Fulfilled）"><a href="#执行态（Fulfilled）" class="headerlink" title="执行态（Fulfilled）"></a>执行态（Fulfilled）</h4><p>处于执行态时，promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个<strong>不可变</strong>的终值</li>
</ul>
<h4 id="拒绝态（Rejected）"><a href="#拒绝态（Rejected）" class="headerlink" title="拒绝态（Rejected）"></a>拒绝态（Rejected）</h4><p>处于拒绝态时，promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个<strong>不可变</strong>的据因</li>
</ul>
<p>这里的不可变指的是恒等（即可用 <code>===</code> 判断相等），而不是意味着更深层次的不可变（<strong>译者注：</strong> 盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。</p>
<h3 id="Then-方法"><a href="#Then-方法" class="headerlink" title="Then 方法"></a><strong>Then 方法</strong></h3><p>一个 promise 必须提供一个 <code>then</code> 方法以访问其当前值、终值和据因。</p>
<p>promise 的 <code>then</code> 方法接受两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<h4 id="参数可选"><a href="#参数可选" class="headerlink" title="参数可选"></a>参数可选</h4><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p>
<ul>
<li>如果 <code>onFulfilled</code> 不是函数，其必须被忽略</li>
<li>如果 <code>onRejected</code> 不是函数，其必须被忽略</li>
</ul>
<h4 id="onFulfilled-特性"><a href="#onFulfilled-特性" class="headerlink" title="onFulfilled 特性"></a><code>onFulfilled</code> 特性</h4><p>如果 <code>onFulfilled</code> 是函数：</p>
<ul>
<li>当 <code>promise</code> 执行结束后其必须被调用，其第一个参数为 <code>promise</code> 的终值</li>
<li>在 <code>promise</code> 执行结束前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h4 id="onRejected-特性"><a href="#onRejected-特性" class="headerlink" title="onRejected 特性"></a><code>onRejected</code> 特性</h4><p>如果 <code>onRejected</code> 是函数：</p>
<ul>
<li>当 <code>promise</code> 被拒绝执行后其必须被调用，其第一个参数为 <code>promise</code> 的据因</li>
<li>在 <code>promise</code> 被拒绝执行前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href="http://es5.github.io/#x10.3" target="_blank" rel="noopener">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用<a href="#note-1">注1</a></p>
<h4 id="调用要求"><a href="#调用要求" class="headerlink" title="调用要求"></a>调用要求</h4><p><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值）<sup><a href="#note-2">注2</a></sup></p>
<h4 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h4><p><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p>
<ul>
<li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li>
<li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li>
</ul>
<h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p><code>then</code> 方法必须返回一个 <code>promise</code> 对象 <sup><a href="#note-3">注3</a></sup></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li>
<li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li>
<li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的据因</li>
</ul>
<p><strong>译者注：</strong> 理解上面的“返回”部分非常重要，即：<strong>不论 <code>promise1</code> 被 reject 还是被 resolve 时 <code>promise2</code> 都会被 resolve，只有出现异常时才会被 rejected</strong>。</p>
<h3 id="Promise-解决过程"><a href="#Promise-解决过程" class="headerlink" title="Promise 解决过程"></a><strong>Promise 解决过程</strong></h3><p><strong>Promise 解决过程</strong> 是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p>
<p>这种 <em>thenable</em> 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 <code>then</code> 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>运行 <code>[[Resolve]](promise, x)</code> 需遵循以下步骤：</p>
<h4 id="x-与-promise-相等"><a href="#x-与-promise-相等" class="headerlink" title="x 与 promise 相等"></a><code>x</code> 与 <code>promise</code> 相等</h4><p>如果 <code>promise</code> 和 <code>x</code> 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 <code>promise</code></p>
<h4 id="x-为-Promise"><a href="#x-为-Promise" class="headerlink" title="x 为 Promise"></a><code>x</code> 为 Promise</h4><p>如果 <code>x</code> 为 Promise ，则使 <code>promise</code> 接受 <code>x</code> 的状态 <sup><a href="#note-4">注4</a></sup>：</p>
<ul>
<li>如果 <code>x</code> 处于等待态， <code>promise</code> 需保持为等待态直至 <code>x</code> 被执行或拒绝</li>
<li>如果 <code>x</code> 处于执行态，用相同的值执行 <code>promise</code></li>
<li>如果 <code>x</code> 处于拒绝态，用相同的据因拒绝 <code>promise</code></li>
</ul>
<h4 id="x-为对象或函数"><a href="#x-为对象或函数" class="headerlink" title="x 为对象或函数"></a><code>x</code> 为对象或函数</h4><p>如果 <code>x</code> 为对象或者函数：</p>
<ul>
<li>把 <code>x.then</code> 赋值给 <code>then</code> <sup><a href="#note-5">注5</a></sup></li>
<li>如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
<li>如果 <code>then</code> 是函数，将 <code>x</code> 作为函数的作用域 <code>this</code> 调用之。传递两个回调函数作为参数，第一个参数叫做 <code>resolvePromise</code> ，第二个参数叫做 <code>rejectPromise</code>:<ul>
<li>如果 <code>resolvePromise</code> 以值 <code>y</code> 为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></li>
<li>如果 <code>rejectPromise</code> 以据因 <code>r</code> 为参数被调用，则以据因 <code>r</code> 拒绝 <code>promise</code></li>
<li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li>
<li>如果调用 <code>then</code> 方法抛出了异常 <code>e</code>：<ul>
<li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之</li>
<li>否则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
</ul>
</li>
<li>如果 <code>then</code> 不是函数，以 <code>x</code> 为参数执行 <code>promise</code></li>
</ul>
</li>
<li>如果 <code>x</code> 不为对象或者函数，以 <code>x</code> 为参数执行 <code>promise</code></li>
</ul>
<p>如果一个 promise 被一个循环的 <em>thenable</em> 链中的对象解决，而 <code>[[Resolve]](promise, thenable)</code> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 <code>TypeError</code> 为据因来拒绝 <code>promise</code> <sup><a href="#note-6">注6</a></sup>。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><hr>
<ul>
<li><p><b id="note-1">注1</b> 这里的<strong>平台代码</strong>指的是引擎、环境以及 promise 的实施代码。实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（<strong>译者注：</strong> 即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列或<a href="https://en.wikipedia.org/wiki/Trampoline_(computing" target="_blank" rel="noopener">『跳板』</a>)。</p>
<p>  <strong>译者注：</strong> 这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p>
<p>  两个类别的具体分类如下：</p>
<ul>
<li><strong>macro-task:</strong> script（整体代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I/O, UI rendering</li>
<li><p><strong>micro-task:</strong> <code>process.nextTick</code>, <code>Promises</code>（这里指浏览器实现的原生 Promise）, <code>Object.observe</code>, <code>MutationObserver</code></p>
<p>详见 <a href="http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context" target="_blank" rel="noopener">stackoverflow 解答</a> 或 <a href="http://wengeezhang.com/?p=11" target="_blank" rel="noopener">这篇博客</a></p>
</li>
</ul>
</li>
<li><p><b id="note-2">注2</b> 也就是说在 <strong>严格模式（strict）</strong> 中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。</p>
</li>
<li><p><b id="note-3">注3</b> 代码实现在满足所有要求的情况下可以允许 <code>promise2 === promise1</code> 。每个实现都要文档说明其是否允许以及在何种条件下允许 <code>promise2 === promise1</code> 。</p>
</li>
<li><p><b id="note-4">注4</b> 总体来说，如果 <code>x</code> 符合当前实现，我们才认为它是真正的 <em>promise</em> 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。</p>
</li>
<li><p><b id="note-5">注5</b> 这步我们先是存储了一个指向 <code>x.then</code> 的引用，然后测试并调用该引用，以避免多次访问 <code>x.then</code> 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。</p>
</li>
<li><p><b id="note-6">注6</b> 实现不应该对 <em>thenable</em> 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 <code>TypeError</code> 异常；如果一条无限长的链上 <em>thenable</em> 均不相同，那么递归下去永远是正确的行为。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英文原文：&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Promise/A+&lt;/a&gt;&lt;br&gt;图灵译文：&lt;a href=&quot;http://www.ituring.com.cn/article/66566&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【翻译】Promises/A+规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者序：&lt;/strong&gt;一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="翻译" scheme="http://malcolmyu.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Promise" scheme="http://malcolmyu.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>JSDoc 配置使用概览</title>
    <link href="http://malcolmyu.github.io/2015/04/25/Introduction-of-Jsdoc/"/>
    <id>http://malcolmyu.github.io/2015/04/25/Introduction-of-Jsdoc/</id>
    <published>2015-04-24T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.783Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>尽管一个好的项目文档能让项目增光添彩，但文档的作用始终是锦上添花而非雪中送炭，对于开发者来说，费尽心神的整理项目文档似乎也并非是一件令人愉快的事情。在使用题中所述的工具——jsdoc和编写本文的同时，笔者也是几度懊恼：这东西在项目中真的有用吗？是不是有点浪费时间？但随着项目体量的增大和开发人员的增多，使用并自动化维护一份好的文档所带来的优势也是逐渐显现。笔者也决心写一篇科普小文，说一说文档工具的使用注意要点。</p>
<a id="more"></a>
<h2 id="JSDoc-命令行使用方法"><a href="#JSDoc-命令行使用方法" class="headerlink" title="JSDoc 命令行使用方法"></a>JSDoc 命令行使用方法</h2><p>通过命令行来生成 JSDoc 有两种适合前端的方式：一种是通过 npm 来安装 jsdoc 来生成文档，需要学习相关的命令行参数与配置文件的编写；另一种是使用 grunt 来生成 jsdoc，这种方法配置起来比较简单，等于将各种配置参数写在了 Gruntfile.js 的配置项里，然后可以自定义各种操作命令，十分灵活。下面就分别就这两种方法介绍一下。</p>
<h3 id="通过-npm-生成"><a href="#通过-npm-生成" class="headerlink" title="通过 npm 生成"></a>通过 npm 生成</h3><p>通过 npm 的生成方式主要包含安装、配置和生成三步。安装的方式如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jsdoc -g</span><br></pre></td></tr></table></figure>
<p>然后去指定文件（如 <code>test.js</code>）的路径下运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jsdoc test.js</span><br></pre></td></tr></table></figure>
<p>文档即可被生成在根目录下的 out 文件夹中。</p>
<p>上面的过程看上去十分简便，但我们省略了配置这一步，如果我们不想生成在 out 文件夹下怎么办？我们想针对一个项目工程生成文档怎么办？觉得原有文档模板太丑想换个风格怎么办（<em>说句实话个人感觉默认模板是目前见过所有模板中最好看的……</em>）？这就需要在配置这一步中进行繁杂的个性化指定。对于项目的个性化指定可以通过<strong>配置文件</strong>和<strong>命令行参数</strong>两种方式来设置，先说一下命令行参数的配置。</p>
<p>有关命令行参数的配置可以参考<a href="http://usejsdoc.org/about-commandline.html" target="_blank" rel="noopener">官网文档</a>的详细说明，这里只列出几个重要的参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">全称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-c</code></td>
<td style="text-align:left"><code>--configure</code></td>
<td style="text-align:left">引入配置项，默认为 jsdoc 安装目录的 <code>config.json</code> 文件</td>
</tr>
<tr>
<td style="text-align:left"><code>-d</code></td>
<td style="text-align:left"><code>--destination</code></td>
<td style="text-align:left">配置文档输出的目录，默认为 <code>./out</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-P</code></td>
<td style="text-align:left"><code>--package</code></td>
<td style="text-align:left">可以将 <code>package.json</code> 文件写入文档中，默认写入当前路径的第一个 <code>package.json</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-r</code></td>
<td style="text-align:left"><code>--recurse</code></td>
<td style="text-align:left">递归调用路径的子目录查找 js 文件，当生成一个文件夹下的全部 js 的文档时必须使用这个参数</td>
</tr>
<tr>
<td style="text-align:left"><code>-R</code></td>
<td style="text-align:left"><code>--readme</code></td>
<td style="text-align:left">可以引入一个说明文件，默认将当前路径中的第一个 <code>readme.md</code> 文件添加到文档中</td>
</tr>
<tr>
<td style="text-align:left"><code>-t</code></td>
<td style="text-align:left"><code>--template</code></td>
<td style="text-align:left">可以给文档指定一个第三方的模板</td>
</tr>
</tbody>
</table>
<p>举个例子，比如我们要将 <code>./src</code> 路径下的所有 js 文件生成文档，然后存放在 <code>./docs</code> 文件夹中，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jsdoc src -r -d docs</span><br></pre></td></tr></table></figure>
<p>但是这样感觉还是不方便，如何对特定文件进行文档解析呢？如果有一些文件不想进行文档解析如何从中间剔除呢？而且每次都要输入如此复杂的命令行参数也十分不方便。要解决这些问题，就需要用到配置文件 <code>conf.json</code> 了。</p>
<p>对于配置文件的详细解释可以参见<a href="http://usejsdoc.org/about-configuring-jsdoc.html" target="_blank" rel="noopener">官方文档</a>的说明，这里也是举一个简单的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tags"</span>: &#123;</span><br><span class="line">        <span class="attr">"allowUnknownTags"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"source"</span>: &#123;</span><br><span class="line">        <span class="attr">"include"</span>: [<span class="string">"./src/lib"</span>, <span class="string">"./src/util"</span>],</span><br><span class="line">        <span class="attr">"exclude"</span>: [<span class="string">"./src/lib/demo"</span>],</span><br><span class="line">        <span class="attr">"includePattern"</span>: <span class="string">".+\\.js$"</span>,</span><br><span class="line">        <span class="attr">"excludePattern"</span>: <span class="string">"(^|\\/|\\\\)_"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"opts"</span>: &#123;</span><br><span class="line">        <span class="attr">"recurse"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tags.allowUnknownTags</code> 表示允许使用为定义的 tag 标签，不然使用未知标签会报错；</li>
<li><code>source.include</code> 表示需要进行文档解析的文件（夹）路径；</li>
<li><code>source.exclude</code> 表示不需要解析的文件（夹）路径；</li>
<li><code>source.includePattern</code> 表示要进行文档解析的文件类型，支持正则进行文件名匹配，上文表示只能解析 *.js 文件；</li>
<li><code>source.excludePattern</code> 表示不要进行解析的文件类型，上文表示所有以下划线开头的文件和文件夹都不被解析；</li>
<li><code>opts.recurse</code> 表示是否递归解析文件夹，上文表示继续拧递归解析，即使用 <code>-r</code> 参数。</li>
</ul>
<p>这里的 <code>opts</code> 里面的内容与上表中命令行参数配置的内容一致，即也可以在此处配置各种参数，详情官网文档中有叙述。将上文保存为一个 json 格式的文件，然后使用 <code>-c</code> 参数引入，就可以按照设定好的规则直接批量生成文档了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jsdoc -c conf.json</span><br></pre></td></tr></table></figure>
<h3 id="通过-grunt-生成"><a href="#通过-grunt-生成" class="headerlink" title="通过 grunt 生成"></a>通过 grunt 生成</h3><p>在项目中如果使用了 grunt 工具，也可以将 jsdoc 集成到 grunt 中去。这种方式十分的简便，在其 <a href="https://github.com/krampstudio/grunt-jsdoc" target="_blank" rel="noopener">github 地址</a>上也有详尽的介绍，具体流程与其他的 grunt 模块差别不大，使用如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install grunt-jsdoc --save-dev</span><br></pre></td></tr></table></figure>
<p>然后在 <code>Gruntfile.js</code> 文件中进行配置，就可以在命令行中使用了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    jsdoc: &#123;</span><br><span class="line">        dist: &#123;</span><br><span class="line">            <span class="comment">// 必填项，需要生成文档的路径数组，也可以将 README.md 文件加入其中</span></span><br><span class="line">            src: [<span class="string">'src/*.js'</span>, <span class="string">'test/*.js'</span>],</span><br><span class="line">            <span class="comment">// 可选项，jsdoc bin 文件路径，一般不写，会自己在 node_modules 中寻找</span></span><br><span class="line">            jsdoc: <span class="string">''</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                <span class="comment">// 必填项，生成文件的路径</span></span><br><span class="line">                destination: <span class="string">'./docs/'</span>,</span><br><span class="line">                <span class="comment">// 可选项，conf 文件的路径</span></span><br><span class="line">                configure: <span class="string">'conf.json'</span>,</span><br><span class="line">                <span class="comment">// 可选项，模板路径</span></span><br><span class="line">                template: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">grunt.task.loadNpmTasks(<span class="string">'grunt-jsdoc'</span>);</span><br><span class="line">grunt.task.registerTask(<span class="string">'doc'</span>, [<span class="string">'jsdoc'</span>]);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grunt doc</span><br></pre></td></tr></table></figure>
<p>需要注意的是，配置项中的 <code>options</code> 内容与 <code>conf.json</code> 中 <code>opts</code> 的内容也一致。</p>
<h2 id="JSDoc-注释规范"><a href="#JSDoc-注释规范" class="headerlink" title="JSDoc 注释规范"></a>JSDoc 注释规范</h2><p>上面的一堆其实都是虚的，最主要的还是在代码中按照 JSDoc 要求的注释规范详尽的写清楚注释。JSDoc 的注释有一条很重要的规范就是：</p>
<blockquote>
<p> It must start with a <code>/**</code> sequence in order to be recognized by the JSDoc parser. Comments beginning with <code>/*</code>, <code>/***</code>, or more than 3 stars will be ignored. This is a feature to allow you to suppress parsing of comment blocks.</p>
</blockquote>
<blockquote>
<p>必须以 <code>/**</code> 开头才能被 JSDoc 的解析器识别。 以 <code>/*</code>、<code>/***</code>、 或者超过三个 <code>*</code> 开头的注释我们都不管。这可是我们做的一个 feature 哟~它可以帮助你避免解析你不想解析的注释。</p>
</blockquote>
<p>使用 <code>/**</code> 开始注释之后，就需要研究一下注释的标签（Tags），JSDoc 提供了几十种标签，满足我们各种稀奇古怪的需求。我们先从单个文件的注释说起，对 JSDoc 的注释规范进行说明。</p>
<h3 id="单个文件注释"><a href="#单个文件注释" class="headerlink" title="单个文件注释"></a>单个文件注释</h3><p>提到单个文件注释，首先要说到 JSDoc 里面的一个概念，换做<strong>块级标签（Block Tag）</strong>与<strong>行内标签（Block Tag）</strong>，整的这么玄乎，无非就是说有些标签是用 <code>@</code> 打头起一行，叫做块级；有些标签是用 <code>{}</code> 包裹放在行内，最常见的就是 <code>@type</code> 和 <code>@link</code> 标签，可以放在行内对变量进行类型说明与解释。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大哥大嫂过年好</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; parent - 你是我的爷</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; child - 我是你的儿</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">happyNewYear</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是单文件注释中常用的标签：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标签</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>@alias</code></td>
<td style="text-align:left">同名引用，用于指定一个同名属性或在非显示的情况下标明从属关系，详见下节</td>
</tr>
<tr>
<td style="text-align:left"><code>@author</code></td>
<td style="text-align:left">说明这篇代码谁写的，<del>方便出 bug 的时候削人</del></td>
</tr>
<tr>
<td style="text-align:left"><code>@class</code> <code>@constructor</code></td>
<td style="text-align:left">标记一个函数为构造函数，可以使用 <code>new</code> 来实例化</td>
</tr>
<tr>
<td style="text-align:left"><code>@constant</code> <code>@const</code></td>
<td style="text-align:left">将一个变量标记为常量</td>
</tr>
<tr>
<td style="text-align:left"><code>@description</code> <code>@desc</code></td>
<td style="text-align:left">进行描述，一般会把注释开头的文字默认作为描述</td>
</tr>
<tr>
<td style="text-align:left"><code>@enum</code></td>
<td style="text-align:left">标注一个对象为枚举对象</td>
</tr>
<tr>
<td style="text-align:left"><code>@example</code></td>
<td style="text-align:left">可以给文档提供一个如何使用的例子</td>
</tr>
<tr>
<td style="text-align:left"><code>@file</code> <code>@fileoverview</code> <code>@overview</code></td>
<td style="text-align:left">表示对一个文件的描述</td>
</tr>
<tr>
<td style="text-align:left"><code>@global</code></td>
<td style="text-align:left">标记一个全局变量</td>
</tr>
<tr>
<td style="text-align:left"><code>@param</code></td>
<td style="text-align:left">标记一个函数的参数</td>
</tr>
<tr>
<td style="text-align:left"><code>@returns</code> <code>@return</code></td>
<td style="text-align:left">标记一个函数的返回值</td>
</tr>
<tr>
<td style="text-align:left"><code>@this</code></td>
<td style="text-align:left">标注一个 <code>this</code> 关键字的指向</td>
</tr>
</tbody>
</table>
<p>但是在项目中，我们可能拥有一堆又一堆的单个文件都需要添加注释，总不能把这些方法啊变量啊的注释都丢到一个文档页面中吧。不用担心，JSDoc 提供了一种模块化注释的方式帮我们解决这一问题。</p>
<h3 id="模块化注释"><a href="#模块化注释" class="headerlink" title="模块化注释"></a>模块化注释</h3><p>JSDoc 中对模块的表示共有三种方法，分别为<strong>类（<code>@class</code>）</strong>、<strong>模块（<code>@module</code>）</strong>和<strong>命名空间（<code>@namespace</code>）</strong>。使用上面三个标签进行标注的话，其从属的属性都可以使用长名进行引用。<code>@module</code> 顾名思义是用来标注一个 JS 模块的，一般用这个模块再被 <code>require</code> 的时候的写法作为名字标注。比如这样一个模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表单校验模块</span></span><br><span class="line"><span class="comment"> * @module lib/validator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 校验通过方法 */</span></span><br><span class="line">exports.valid = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">/** 校验失败方法 */</span></span><br><span class="line">exports.inValid = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个文件在使用时需要这样用</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'lib/validator'</span>);</span><br></pre></td></tr></table></figure>
<p>正如上文所写，对于一个模块需要 <code>exports</code> 的方法可以直接写双星注释，会被 JSDoc 所自动识别。但有些情况下为了我们可能会先给一个本地对象挂一堆方法然后把这个对象直接 <code>exports</code>。为了标明它们的从属关系，我们就可以用到 <code>@alias</code> 别名标签。如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表单校验模块</span></span><br><span class="line"><span class="comment"> * @module lib/validator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @alias module:lib/validator.valid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> valid = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.valid = valid;</span><br></pre></td></tr></table></figure>
<p>注意到上文中别名标签的值，这里用到一个叫做<strong>命名路径（namepaths）</strong>的概念。这个概念表示使用 <code>#</code> <code>.</code> <code>~</code> 三种符号表示两个模块之间的从属关系，其分别为：</p>
<ul>
<li><code>#</code> 实例属性，表示实例对象能够继承的属性；</li>
<li><code>.</code> 静态属性，普通对象的静态属性；</li>
<li><code>~</code> 内部属性，在函数对象内部作用域定义的属性。</li>
</ul>
<p>下面这个例子分别解释了上面三种属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @constructor */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.instanceSay = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是实例属性"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerSay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是内部属性"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.staticSay = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我是静态属性"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在注释中我们就可以使用这样的方式来表示上面三种属性</span></span><br><span class="line"><span class="comment">// Person#instanceSay</span></span><br><span class="line"><span class="comment">// Person.staticSay</span></span><br><span class="line"><span class="comment">// Person~innerSay</span></span><br></pre></td></tr></table></figure>
<p>上面用命名路径生成的诸如 <code>Person#instanceSay.hello~hi</code> 这样的引用名称就叫做<strong>长名（longname）</strong>。其中如果是 <code>@module</code> 模块的话，需要添加 <code>module:</code> 前缀，用于与命名空间相区分。而命名空间的作用就是给其子属性开启一个可以被挂载的空间，可以在文档中被单独标记。子属性可以使用 <code>@memberof</code> 对父属性进行挂载。比如我们挂载到全局变量上的属性，并不遵循模块化的风格，对其进行标记就可以使用命名空间的方式，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 某个文件中的祖先空间</span></span><br><span class="line"><span class="comment"> * @namespace ancestor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ancestor = &#123;&#125;;</span><br><span class="line"><span class="built_in">window</span>.ancestor = ancestor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 某个文件中的父亲空间，挂载到祖先之下</span></span><br><span class="line"><span class="comment"> * @namespace parent</span></span><br><span class="line"><span class="comment"> * @memberof ancestor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> parent = &#123;&#125;;</span><br><span class="line"><span class="built_in">window</span>.ancestor.parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 某个文件中的孩子空间，挂载到父亲之下，需要用长名</span></span><br><span class="line"><span class="comment"> * @namespace child</span></span><br><span class="line"><span class="comment"> * @memberof ancestor.parent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> child = &#123;&#125;;</span><br><span class="line"><span class="built_in">window</span>.ancestor.parent.child = child;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这种模块化的标签似乎 JSDoc 都会对其进行作用域的识别，因此在注释的时候一定要注意作用域的问题。比如对一个文件整个注释为 <code>@module</code>，其内部的 <code>@namespace</code> 可能就会失效，无法在文档上良好的反应。以下是模块化注释的常用标签：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标签</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>@event</code></td>
<td style="text-align:left">在模板中标记可以被触发的事件，可与 <code>@fires</code> 标签配合使用</td>
</tr>
<tr>
<td style="text-align:left"><code>@fires</code> <code>@emit</code></td>
<td style="text-align:left">模块通信触发事件描述，需要与 <code>@event</code> 标签配合使用</td>
</tr>
<tr>
<td style="text-align:left"><code>@inner</code></td>
<td style="text-align:left">模块内部变量标注</td>
</tr>
<tr>
<td style="text-align:left"><code>@memberof</code></td>
<td style="text-align:left">标记模块之间的从属关系</td>
</tr>
<tr>
<td style="text-align:left"><code>@module</code></td>
<td style="text-align:left">标记一个 CMD 或是 AMD 的模块</td>
</tr>
<tr>
<td style="text-align:left"><code>@namespace</code></td>
<td style="text-align:left">开启命名空间</td>
</tr>
<tr>
<td style="text-align:left"><code>@see</code></td>
<td style="text-align:left">可以在文档中进行跳转，需要使用长名来进行连接</td>
</tr>
</tbody>
</table>
<p><em>参考链接</em></p>
<ul>
<li><a href="https://github.com/jsdoc3/jsdoc" target="_blank" rel="noopener">jsdoc - Github</a>： jsdoc npm module 的 Github 地址</li>
<li><a href="http://usejsdoc.org/index.html" target="_blank" rel="noopener">jsdoc 官网</a> ：jsdoc 官方文档</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管一个好的项目文档能让项目增光添彩，但文档的作用始终是锦上添花而非雪中送炭，对于开发者来说，费尽心神的整理项目文档似乎也并非是一件令人愉快的事情。在使用题中所述的工具——jsdoc和编写本文的同时，笔者也是几度懊恼：这东西在项目中真的有用吗？是不是有点浪费时间？但随着项目体量的增大和开发人员的增多，使用并自动化维护一份好的文档所带来的优势也是逐渐显现。笔者也决心写一篇科普小文，说一说文档工具的使用注意要点。&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://malcolmyu.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="jsdoc" scheme="http://malcolmyu.github.io/tags/jsdoc/"/>
    
  </entry>
  
  <entry>
    <title>avalon 事件总线与依赖调度系统</title>
    <link href="http://malcolmyu.github.io/2015/04/19/Avalon-Event-Bus/"/>
    <id>http://malcolmyu.github.io/2015/04/19/Avalon-Event-Bus/</id>
    <published>2015-04-18T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在工作中经常使用到<a href="http://www.cnblogs.com/rubylouvre/" target="_blank" rel="noopener">司徒</a>的 <a href="https://github.com/RubyLouvre/avalon" target="_blank" rel="noopener">avalon</a> ，由于坑点太多，有时需要经常查阅其源码实现。而 avalon 由于方兴未艾，网上对其进行源码解析的文章并不多，查了半天也就只有这篇 <a href="http://www.cnblogs.com/sskyy/p/3679572.html" target="_blank" rel="noopener">MVVM 大比拼</a>，以及这篇 <a href="http://www.cnblogs.com/aaronjs/archive/2013/06/16/3138631.html" target="_blank" rel="noopener">avalon 源码分析</a>。个人认为这两篇文章写得都并不算好，其一是成文较早，研究的源码还是 1.2.5 版本，而目前的新版本已经到了 1.4+，比之前不知道高到哪里去。其二是大比拼一文作者阅码无数，心中早已无码，写分析只观其大要，似乎在和原作者谈笑风生；而后者的分析仿佛又只是对源码的粗略通读，也没怎么经过实践，有些图样图森破。因此自己决定安下心来写点源码分析。</p>
<a id="more"></a>
<p>本文源起自同事的一个疑问，“<em>可否使用事件中的 <code>$fire</code> 来改变一个普通双绑属性的值？</em>”这样问也是有它的理由：因为在视图模型中，可以用 <code>$watch</code> 来监听属性的变化；而在事件总线中，可以用 <code>$fire</code> 来触发 <code>$watch</code> 的回调，那似乎用 <code>$fire</code> 来改变双绑属性的值也变得可以接受。但实际测试中，发现这样操作是不起作用的。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = avalon.define(&#123;</span><br><span class="line">    $id: <span class="string">'demo'</span>,</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">demo.$fire(<span class="string">'a'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// nothing output</span></span><br></pre></td></tr></table></figure>
<p>这是为什么呢？起初我认为事件总线与依赖调度实际上是绑在一起的，也就是说双绑属性上的事件——如值改变后通知视图——也是通过事件总线来实现的；后来想到 avalon 师承 knockout，而事件是 angular 中才有的概念，可能是后来单独实现的也说不定。带着这样的疑问，我翻开了源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventBus = &#123;</span><br><span class="line">    $watch: <span class="function"><span class="keyword">function</span> (<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">"function"</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> callbacks = <span class="keyword">this</span>.$events[type]</span><br><span class="line">            <span class="keyword">if</span> (callbacks) &#123;</span><br><span class="line">                callbacks.push(callback)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.$events[type] = [callback]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//重新开始监听此VM的第一重简单属性的变动</span></span><br><span class="line">            <span class="keyword">this</span>.$events = <span class="keyword">this</span>.$watch.backup</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 省略了 unwatch 事件</span></span><br><span class="line">    $fire: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这里对 $fire 处理 dom 层级关系的部分做了大量省略</span></span><br><span class="line">        <span class="keyword">var</span> callbacks = events[type] || []</span><br><span class="line">        <span class="keyword">var</span> all = events.$all || []</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; callback = callbacks[i++]; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFunction(callback))</span><br><span class="line">                callback.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; callback = all[i++]; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFunction(callback))</span><br><span class="line">                callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在源码中出现最多的东西就是这个 <code>$events</code> 。上面两段代码的主要意思就是说，在 <code>$watch</code> 的时候，查看一下当前层级的 <code>$event</code> 中是否有对应名称的事件队列，在确保 <code>$watch</code> 参数是函数的前提下将回调添加到事件队列中；而 <code>$fire</code> 的时候需要遍历 <code>$event</code> 对应的事件队列，取出是函数的部分执行它。</p>
<p>这里就产生了一个疑问：我之前以为依赖调度的事件也是存放在 <code>$events</code> 队列中的，比如上文的视图模型 demo，加入页面上有写了双绑的 a，如 <code>&lt;span ms-if=&quot;a&quot;&gt;&lt;/span&gt;</code> 之类，那么 a 的依赖调度就是储存在 <code>demo.$events</code> 中的。既然事件总线的回调也是储存在 <code>$events</code> 中，那二者的实现方式又有何区别？</p>
<p>继续翻到依赖调度系统的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerSubscriber</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    Registry[expose] = data</span><br><span class="line">    <span class="comment">// 暴光此函数,方便collectSubscribers收集</span></span><br><span class="line">    <span class="keyword">var</span> fn = data.evaluator</span><br><span class="line">    <span class="keyword">if</span> (fn) &#123; <span class="comment">//如果是求值函数</span></span><br><span class="line">        <span class="keyword">var</span> c = ronduplex.test(data.type) ? data : fn.apply(<span class="number">0</span>, data.args)</span><br><span class="line">        data.handler(c, data.element, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectSubscribers</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = Registry[expose]</span><br><span class="line">    <span class="comment">// 收集依赖于这个访问器的订阅者</span></span><br><span class="line">    <span class="keyword">if</span> (list &amp;&amp; data &amp;&amp; avalon.Array.ensure(list, data) &amp;&amp; data.element) &#123;</span><br><span class="line">        <span class="comment">//只有数组不存在此元素才push进去</span></span><br><span class="line">        addSubscribers(data, list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notifySubscribers</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通知依赖于这个访问器的订阅者更新自身</span></span><br><span class="line">    <span class="keyword">if</span> (list &amp;&amp; list.length) &#123;</span><br><span class="line">        <span class="comment">// 省略了定时检查移除订阅和监控数组的代码</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = list.length, fn; fn = list[--i]; ) &#123;</span><br><span class="line">            <span class="keyword">var</span> fun = fn.evaluator || noop</span><br><span class="line">            fn.handler(fun.apply(<span class="number">0</span>, fn.args || []), el, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过一遍依赖调度的代码我们会发现它的三个主要的功能：</p>
<ul>
<li><code>registerSubscriber</code> 用于给依赖调度系统曝光一个依赖。该方法是在智能代理 <code>parseExprProxy</code> 中调用的，而这一方法是承自 avalon 的两大系统之一——<strong>扫描系统</strong>——在扫描绑定的时候执行的，而参数 <code>data</code> 就是扫描绑定生成的对象。</li>
<li><code>collectSubscribers</code> 用于收集访问器的订阅者。这个方法是在<strong>访问器（accessor）</strong>中进行收集的，当一个属性被 get 的时候进行收集。</li>
<li><code>notifySubscribers</code> 通知依赖于这个访问器的订阅者更新自身。这个方法也是在访问器中进行收集的，对应了属性 set 的情况。</li>
</ul>
<p>由于访问器是在模型工厂中被生成的，也就是说，<strong>依赖调度系统是链接 avalon 两大系统——扫描系统（scan）和模型工厂（define）的重要模块</strong>，是将扫描页面产生的绑定与处理 viewModel 生成的属性结合起来的重要手段。</p>
<p>这是依赖调度系统的功能，这一枝我们按下不表，有机会会开篇详述。我们关注的问题还是在于：为何依赖调度与事件总线都是通过 <code>$events</code> 来进行处理，二者却花开两朵呢？</p>
<p>对上面两个重要的方法进行再一次简化，得到如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerSubscriber</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    Registry[expose] = data</span><br><span class="line">    data.evaluator.apply(<span class="number">0</span>, data.args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectSubscribers</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = Registry[expose]</span><br><span class="line">    avalon.Array.ensure(list, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>registerSubscriber</code> 中，执行了一步求值函数。这时候就会触发访问器的 get 方法，继而触发 <code>collectSubscribers</code>；而后者的参数就是对应的 <code>$events</code>，在这里将刚才曝光的 <code>data</code> 添加到 <code>$events</code> 队列中。这里的 <code>data</code> 不是回调函数，而是扫描绑定生成的数据，包含 DOM 节点、求值函数、vm等等。</p>
<p>看到这里我们就明白了——尽管依赖调度和事件总线的内容都寄存在 <code>$events</code> 中，但一个存的是对象，一个存的是回调函数，所以两者实际上走的是不同的处理路线。</p>
<p>观察一下访问器的代码，证实了我们这一观点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里只探究简单属性，故而对其进行了简化</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>.length) &#123; <span class="comment">// 有参数表示 set</span></span><br><span class="line">    <span class="keyword">if</span> (!isEqual(oldValue, newValue)) &#123;</span><br><span class="line">        $model[name] = newValue</span><br><span class="line">        notifySubscribers($events[name]) <span class="comment">// 同步视图</span></span><br><span class="line">        safeFire($vmodel, name, newValue, oldValue) <span class="comment">// 触发$watch回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 无参数表示 get</span></span><br><span class="line">    collectSubscribers($events[name]) <span class="comment">// 收集视图函数</span></span><br><span class="line">    <span class="keyword">return</span> accessor.svmodel || oldValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在访问器中，需要分别进行同步视图与触发 <code>$watch</code> 回调的操作，分别处理了两个系统的事务。回到之前同事的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = avalon.define(&#123;</span><br><span class="line">    $id: <span class="string">'demo'</span>,</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line">demo.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;);</span><br><span class="line">demo.$fire(<span class="string">'a'</span>, <span class="number">2</span>); <span class="comment">// 输出2</span></span><br><span class="line">demo.a = <span class="number">3</span>;         <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure>
<p>由于依赖调度与事件总线是两个不同的系统，因此 <code>$fire</code> 只能触发事件总线中挂载在 a 上的回调，而无法触发访问器；而由于访问器中在 set 时对两个系统都进行了触发，因此可以即同步视图，又能触发事件回调，所以可以使用 <code>$watch</code> 来监听属性值的变化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中经常使用到&lt;a href=&quot;http://www.cnblogs.com/rubylouvre/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;司徒&lt;/a&gt;的 &lt;a href=&quot;https://github.com/RubyLouvre/avalon&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;avalon&lt;/a&gt; ，由于坑点太多，有时需要经常查阅其源码实现。而 avalon 由于方兴未艾，网上对其进行源码解析的文章并不多，查了半天也就只有这篇 &lt;a href=&quot;http://www.cnblogs.com/sskyy/p/3679572.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVVM 大比拼&lt;/a&gt;，以及这篇 &lt;a href=&quot;http://www.cnblogs.com/aaronjs/archive/2013/06/16/3138631.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;avalon 源码分析&lt;/a&gt;。个人认为这两篇文章写得都并不算好，其一是成文较早，研究的源码还是 1.2.5 版本，而目前的新版本已经到了 1.4+，比之前不知道高到哪里去。其二是大比拼一文作者阅码无数，心中早已无码，写分析只观其大要，似乎在和原作者谈笑风生；而后者的分析仿佛又只是对源码的粗略通读，也没怎么经过实践，有些图样图森破。因此自己决定安下心来写点源码分析。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://malcolmyu.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="avalon" scheme="http://malcolmyu.github.io/tags/avalon/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Promise 探微</title>
    <link href="http://malcolmyu.github.io/2014/08/30/JavaScript-Promise-In-Wicked-Detail/"/>
    <id>http://malcolmyu.github.io/2014/08/30/JavaScript-Promise-In-Wicked-Detail/</id>
    <published>2014-08-29T16:00:00.000Z</published>
    <updated>2019-08-18T12:24:41.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原文链接：<a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/" target="_blank" rel="noopener">JavaScript Promises … In Wicked Detail</a></p>
<p>我在 JavaScript 中使用 Promise 已经有一段时间了，目前我已经能高效的使用这一开始让我晕头转向的东西。但真要细说起来，我发现还是不能完全理解它的实现原理，这也正是本文写作的目的所在。如果诸位读者也处在一知半解的状态，那请读完这篇文章，相信你也会像我一样对 Promise 有更好的理解。</p>
<a id="more"></a>
<p>我们将会循序渐进的建立一个 Promise 的实现，最终这个实现会基本符合 <a href="http://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+ 规范</a>，在此过程中你会逐步的了解到 Promise 是如何实现了异步编程的需求。本文假设你已经有了一定的 Promise 基础，如果你对此一无所知，请移步<a href="https://www.promisejs.org/" target="_blank" rel="noopener">官网</a>先了解学习一下。</p>
<h2 id="为什么要写这篇文章？"><a href="#为什么要写这篇文章？" class="headerlink" title="为什么要写这篇文章？"></a>为什么要写这篇文章？</h2><p>有些童鞋会问：为啥我们要对 Promise 了解得这么细呢，会用不就好了么？其实理解了一个东西的实现机理，可以提升你使用它的能力和效率，同时在使用出错的时候能更有效地 debug —— 我之所以写这篇文章就是因为有一次和同事掉进一个关于 Promise 的奇怪的坑里去了。要是当年我就和现在这样了解得这么透彻，我就不会掉坑了~</p>
<h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>让我们从最简单的例子开始实现我们的 Promise 实例，我想将这样的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a value:'</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现为这样的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a value:'</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了实现这个效果，我们只需要将 <code>donSomething()</code> 函数从这样的形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">42</span>;</span><br><span class="line">  callback(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改成这种 “Promise” 基础版：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="number">42</span>;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法只是给我们的回调模式写了一个简单且毫无意义的语法糖。我们目前还没有触及 Promise 背后的核心概念，但这也是个小小的开始。</p>
<p><strong>Promise 可以捕获最终值（the eventual value）这一概念并将其置入对象</strong></p>
<p>这正是 Promise 的有趣之处（<strong>译者注：</strong>所谓的最终值，实际上是规范里面的一个概念，表示异步操作的最终获取值。实际上上面这句话的意思就是将我们要传给回调函数的终值也保存在 Promise 对象里）。在后面的探索中，我们就会发现：一旦最终值的概念可以被这样捕获到，我们就可以干一些非常给力的事情。</p>
<h3 id="定义-Promise-类型"><a href="#定义-Promise-类型" class="headerlink" title="定义 Promise 类型"></a>定义 Promise 类型</h3><p>让我们进行下一步，定义一个实际的 <code>Promise</code> 类型来扩展上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    callback(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用 Promise 类型重写 <code>doSomething()</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">42</span>;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就遇到一个问题：如果你逐行执行代码，就会发现 <code>resolve()</code> 函数在 <code>then()</code> 函数之前被调用，这就意味着 <code>resolve()</code> 被调用的时候，<code>callback</code> 还是 <code>null</code> 。让我们用一个 hack 来干掉这个问题，引入 <code>setTimeout</code>，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将 callback 打出当前执行线程，使之可以被 then 函数设定</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用了这么个毛招，我们的代码终于可以运行啦=。=</p>
<h3 id="这个代码太毛啦"><a href="#这个代码太毛啦" class="headerlink" title="这个代码太毛啦"></a>这个代码太毛啦</h3><p>我们写的图样图森破的 Promise 必须要加入异步操作才能工作，这很容易使之再次失效。只要异步地调用 <code>then()</code> 函数，我们的 callback 又会马上变成 <code>null</code> 了。有作死的读者可能会问：为啥我要写出这么一个破代码让我这么快就感受到失败的挫折？因为我想用上面这个简单易懂的例子将 Promise 的两大关键概念—— <code>then()</code> 和 <code>resolve()</code> 深深地烙印在你的脑海中。它们会阴魂不散地跟随着你哟~</p>
<h2 id="Promise-是有状态（state）的"><a href="#Promise-是有状态（state）的" class="headerlink" title="Promise 是有状态（state）的"></a>Promise 是有状态（state）的</h2><p>我们糟糕易崩溃代码暴露了一个之前我们没有想到的问题—— Promise 是具有状态的。我们在运行之前需要知道其当前所处的状态，并确保我们可以正确地进行状态转换。采用这种方式可以让我的代码稳定性强一些。</p>
<ol>
<li>promise 可以处在等待被赋值的<strong>等待态（pending）</strong>，可以被给予一个值并转为<strong>解决态（resolved）</strong>。</li>
<li>一旦 promise 被一个值 resolve 掉，其就会一直保持这个值并不会再被 resolve。</li>
</ol>
<p><em>（一个 promise 对象也可以被<strong>拒绝 rejected</strong>，我们在稍后的错误处理中会提到）</em></p>
<p>让我们在实例中加入状态的跟踪，以此摆脱之前的毛招：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> deferred;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    state = <span class="string">'resolved'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferred = onResolved;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onResolved(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">    handle(onResolved);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的代码变得更加复杂，但是这样就使得 Promise 对象调用者可以随时激活 <code>then()</code> 函数，被调用的 Promise 对象也可以随时激活 <code>resolve()</code> 方法。这在异步和同步的代码中都是完全适用的。</p>
<p>这正是 <code>state</code> 标志的功劳。新方法 <code>handle()</code> 与之前的两个重要概念 <code>then()</code> 和 <code>resolve()</code> 互不干涉，其将会根据情况在以下两种操作中选择一种执行：</p>
<ul>
<li><code>then()</code> 在 <code>resolve()</code> 之前先被调用，意味着还没有最终值传递给回调函数。这种状态下即为等待态，我们便在内存中保存回调函数以便后续使用。当 <code>resolve()</code> 被调用时，我们激活回调函数并将终值传入。</li>
<li><code>reslove</code> 在 <code>then()</code> 之前被调用，这种情况下我们将终值保存在内存中，一旦 <code>then()</code> 被调用，我们就将终值传入。</li>
</ul>
<p>注意到 <code>setTimeout</code> 不见了么，这个只是暂时的，它还会回来哒~</p>
<p>言归正传：</p>
<p><strong>使用 promises 的时候，我们调用其方法的顺序并不重要，可以按照自己的意愿随时调用 <code>then()</code> 和 <code>resolve()</code>，这就是将终值捕获并置于对象之中保存的强大优势。</strong></p>
<p>尽管我们还有一些事情米有做，我们的 promises 已经非常给力了。这套实现允许我们执行多次 <code>then()</code> —— 其每次都会获取到同样的终值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = doSomething();</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a value:'</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处获取的值和上一处相同</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got the same value again:'</span>, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>（其实吧……这个地方并不是完全正确的，如果我们反过来操作，在执行 <code>resolve()</code> 之前多次执行 <code>then()</code> ，结果只有最后一次的执行会成功。如果要修复这个问题需要在 Promise 对象中维护一个队列来记录回调函数。但由于这篇文章已经够长了，所以我决定不这么搞了=v=）</em></p>
<h2 id="通通连起来吧"><a href="#通通连起来吧" class="headerlink" title="通通连起来吧"></a>通通连起来吧</h2><p>既然 Promise 将异步操作捕获到了对象中，我们就可以对其进行链式操作、map 操作以及串行并行等等其他高效率的操作。下列代码就是一个非常常见的 Promise 用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getSomeData()  </span><br><span class="line">  .then(filterTheData)</span><br><span class="line">  .then(processTheData)</span><br><span class="line">  .then(displayTheData);</span><br></pre></td></tr></table></figure>
<p>由于可以调用 <code>then()</code> 函数，这证明 <code>getSomeData()</code> 返回的是一个 promise 对象；但是第一个怎返回的结果页必须是一个 promise 对象，然后我们才能再次调用 <code>then()</code> 函数（然后再次调用再次调用再次调用~）。而实际的 Promise 实现就是这样的效果，假如我们能够让 <code>then()</code> 函数返回一个 promise 对象，一切就变得更有趣起来。</p>
<p><strong><code>then()</code> 永远返回一个 promise 对象。</strong></p>
<p>以下就是给我们的 promise 假如链式调用的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    state = <span class="string">'resolved'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferred = handler;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!handler.onResolved) &#123;</span><br><span class="line">      handler.resolve(value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret = handler.onResolved(value);</span><br><span class="line">    handler.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onResolved: onResolved,</span><br><span class="line">        resolve: resolve</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额……已经变得有点令人抓狂啦，你是不是在庆幸我们进展的比较缓慢呢~这里的关键之处就在于：<code>then()</code> 函数返回了一个<strong>新的 Promise 对象</strong>。</p>
<p><em>（由于 <code>then()</code> 永远返回一个新的 promise 对象，导致每次都至少有一个 promise 对象被创建、解决然后被忽略，这就产生了一定程度了内存浪费。这是 Promise 被诟病的一个原因，因为传统的回调金字塔就不存在这样的问题。由此你可以理解为啥一些 JavaScript 社区已经抛弃了 promise ）</em></p>
<p>那第二个 promise 要 resolve 的值是什么呢？答案是：<strong>第一个 promise 的返回值</strong>。 <code>handle()</code> 函数的最后两行体现了这一点， <code>handler</code> 对象保存了 <code>onResolved()</code> 回调函数和 <code>resolve()</code> 函数的引用。在链式调用中保存了多个 <code>resolve()</code> 函数的拷贝，每一个 promise 对象的内部都拥有一个自己的 <code>resolve()</code> 方法，并在闭包中运行。 这建立起了第一个 promise 与第二个 promise 之间联系的桥梁。我们在这一行代码 resolve 了第一个 promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ret = handler.onResolved(value);</span><br></pre></td></tr></table></figure>
<p>在上文的例子中，程序里的 <code>handler.onResolved</code> 是这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a value:'</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，这就是我们第一次调用 <code>then()</code> 时传入的处理函数，第一个处理函数的返回值将会用来传递给第二个 promise，链式调用就这么完成啦~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first result'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">88</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">secondResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second result'</span>, secondResult);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果是：</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 第一个结果：42</span></span><br><span class="line"><span class="comment">// 第二个结果：88</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first result'</span>, result);</span><br><span class="line">  <span class="comment">// 没有显示的返回值（也就是 undefined）</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">secondResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second result'</span>, secondResult);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果是：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个结果：42</span></span><br><span class="line"><span class="comment">// 第二个结果：undefined</span></span><br></pre></td></tr></table></figure>
<p>既然 <code>then()</code> 方法永远返回一个新的 promise ，因此这个链式调用就可以越链越深：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first result'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">88</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">secondResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second result'</span>, secondResult);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">thirdResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'third result'</span>, thirdResult);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">fourthResult</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 链呀链...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们如果想在上面的例子中获取每次处理函数调用返回的结果集，就必须在链式调用中人工构建一个存放结果集的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [result];</span><br><span class="line">  results.push(<span class="number">88</span>);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">  results.push(<span class="number">99</span>);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results.join(<span class="string">', '</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 42, 88, 99</span></span><br></pre></td></tr></table></figure>
<p><strong>Promise 每次只会 resolve 一个值，如果你想传递多个值，就需要建立一种存储方式来进行传递（如数组、对象和字符串）</strong></p>
<p>更好的解决途径是使用 Promise 库中的 <code>all()</code> 方法或其他实用的方法来提升 promise 的使用效率，这就有待诸位读者自己挖掘啦。</p>
<h3 id="可选的回调函数"><a href="#可选的回调函数" class="headerlink" title="可选的回调函数"></a>可选的回调函数</h3><p><code>then()</code> 中的回调函数并不是严格要求必写的，加入你不写这个回调， promise 也会用上一个 promise 返回的终值来传递。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got a result'</span>, result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果是：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// got a result 42</span></span><br></pre></td></tr></table></figure>
<p>你可以在 <code>handle()</code> 函数内部观察到这个情况，如果当前的 <code>then()</code> 没有传递回调函数，该函数就会直接使用前一个 promise 返回的终值来解决下一个 promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!handler.onResolved) &#123;</span><br><span class="line">  handler.resolve(value);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链中返回-promise"><a href="#链中返回-promise" class="headerlink" title="链中返回 promise"></a>链中返回 promise</h3><p>我们实现链式的实例还是略显简单，其仅仅是将解决终值传递下去，但如果有个终值就是 promise 咋办？举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(result) &#123;</span><br><span class="line">  <span class="comment">// doSomethingElse 返回一个 promise</span></span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result)</span><br><span class="line">&#125;.then(<span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"the final result is"</span>, finalResult);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>目前来看，上面的结果不会是我们期望的那样。<code>finalResult</code> 不会是的第一个 result 的值，而会是一个 promise 对象。为了达到我们期望的结果（也就是依然让返回值传递下去），我们需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    doSomething().then(result) &#123;</span><br><span class="line">      <span class="comment">// doSomethingElse 返回一个 promise</span></span><br><span class="line">      <span class="keyword">return</span> doSomethingElse(result)</span><br><span class="line">    &#125;.then(<span class="function"><span class="keyword">function</span>(<span class="params">anotherPromise</span>) </span>&#123;</span><br><span class="line">      anotherPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"the final result is"</span>, finalResult);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">=。=但是你会让这一坨翔一样的代码出现在你的项目中么…让我们在 promise 实例中隐式的处理掉这个问题。这个处理方式还是比较简单的，只要在 `</span>resolve()<span class="string">` 方法中加入一个对返回值是 promise 对象的特殊处理就行啦：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(newValue &amp;&amp; <span class="keyword">typeof</span> newValue.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        newValue.then(resolve);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="string">'resolved'</span>;</span><br><span class="line">      value = newValue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">        handle(deferred);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以继续持续的调用 <code>resolve()</code> 直到我们获取到一个 promise。当其返回值不是 promise 对象时，调用链就会和之前一样正常执行。</p>
<p><em>这样的话可能会造成无穷回路（<strong>译者注：</strong>也就是 <code>then()</code> 返回 promise 对象然后又调用 <code>then()</code>）。尽管 A+ 规范里建议 promise 的实现中对无穷回路进行判断，但这种判断是没什么必要的（<strong>译者注：</strong>在规范的最后写了说明，规范本身建议判断，但 promise 的实现并不建议判断）。</em></p>
<p><em>另外，我们这个实现实际上并不完全符合规范，这篇文章里说的东西也没有完全符合规范。假如你对规范本身感兴趣，请移步文章开始处的规范链接。</em></p>
<p>有没有注意到我们对于 <code>newValue</code> 是否为 promise 对象的检测是多么的宽松么，我们只是判断它是否拥有 <code>then()</code> 方法。这个鸭子类型是我故意这么写的（<strong>译者注：</strong>这不是一个 bug，这是个 feature）！这使得不同的 promise 实现可以相互运作，实际上这也是不同的第三方 promise 库的比较常见的混用方式。</p>
<p><strong>不同的 promise 实现只要恰当的遵循规范，就可以相互混用。</strong></p>
<p>搞定了链式调用之后，我们的实现基本接近完成，除了最初被我们完全忽略掉的一个问题 —— <strong>错误处理</strong>。</p>
<h2 id="Promise-的拒绝（reject）"><a href="#Promise-的拒绝（reject）" class="headerlink" title="Promise 的拒绝（reject）"></a>Promise 的拒绝（reject）</h2><p>当一个 promise 运行发生错误，其需要被<strong>拒绝（reject）</strong>并传入一个<strong>原因（reason）</strong>。那么调用者怎么知道何时进行 reject 呢？这可以通过给 <code>then()</code> 函数的第二个参数传入回调来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Success!'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Uh oh'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>正如之前所提到的那样，promise 对象可以从 pending 转换到 resolved 或者 rejected，但不能同时 resolved 和 rejected。换言之，<code>then</code> 的两个回调中仅有一个会被调用。</strong></p>
<p>Promise 可以通过 <code>resolve()</code> 方法的孪生兄弟 —— <code>reject()</code> 方法来实现拒绝。下面是给 <code>doSomething()</code> 加入错误处理的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = somehowGetTheValue();</span><br><span class="line">    <span class="keyword">if</span>(result.error) &#123;</span><br><span class="line">      reject(result.error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(result.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们 promise 的实现中，我们也必须考虑到 reject 。一旦一个 promise 被拒绝，其后面的调用链中的 promise 也必须被拒绝。</p>
<p>让我们再来一起看一下完成版的 promise 实例的实现，这其中加入了拒绝的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(newValue &amp;&amp; <span class="keyword">typeof</span> newValue.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">      newValue.then(resolve, reject);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="string">'resolved'</span>;</span><br><span class="line">    value = newValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    state = <span class="string">'rejected'</span>;</span><br><span class="line">    value = reason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferred = handler;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handlerCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">      handlerCallback = handler.onResolved;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlerCallback = handler.onRejected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!handlerCallback) &#123;</span><br><span class="line">      <span class="keyword">if</span>(state === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">        handler.resolve(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.reject(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret = handlerCallback(value);</span><br><span class="line">    handler.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onResolved: onResolved,</span><br><span class="line">        onRejected: onRejected,</span><br><span class="line">        resolve: resolve,</span><br><span class="line">        reject: reject</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除去额外加入的 <code>reject()</code> 函数，<code>handle()</code> 函数本身也能对拒绝进行应对。其根据 <code>state</code> 的值来决定进行 resolve 还是 reject，而后 <code>state</code> 的值会被推送到下一个 promise 中，作为决定下个 promise 进行解决还是拒绝的依据（<strong>译者注：</strong>在这个实现中，并没有体现出这一点。因为本实例使用的是 <code>then()</code> 链而不是 <code>done()</code>  <code>fail()</code> 链，每次传递的都是一个新的 promise 对象，因此上一个 promise 被拒绝了，也仅仅会把其拒绝回调函数的返回值传递给下一个链的 resolve 回调。言下之意，本实例中的只有第一个 promise 对象可以被拒绝，第二个起直到链尾的 promise 其拒绝回调都无法被调用 —— 除非发生下一章节的非预期异常，有兴趣的读者可以自己试一试）。</p>
<p><em>当使用 promise 的时候，我们很容易把错误处理的回调省略掉，但这样会导致我们无法捕获到任何报错。你至少应该在链式 promise 的最后写一个错误处理回调。这里可以参加下一章的错误吞没。</em></p>
<h3 id="非预期的错误也应该被拒绝"><a href="#非预期的错误也应该被拒绝" class="headerlink" title="非预期的错误也应该被拒绝"></a>非预期的错误也应该被拒绝</h3><p>目前我们处理的错误仅仅是已知的错误，但也可能突然蹦出来一个意料之外的错误然后把一切搞崩掉。因此 promise 实例对这些异常进行捕获并拒绝也是十分必要的。</p>
<p>这就意味着 <code>resolve()</code> 方法需要被包裹在 try/catch 语句块中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... 这里和以前一样</span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证 <code>then()</code> 中传入的回调函数不会抛出一些无法处理的异常也很重要。由于这些回调在 <code>handle()</code> 中被调用，因此我们最终的实现结果是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 一切如前</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ret = handlerCallback(value);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    handler.reject(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handler.resolve(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="promises-可能吞没错误！"><a href="#promises-可能吞没错误！" class="headerlink" title="promises 可能吞没错误！"></a>promises 可能吞没错误！</h3><p>（<strong>译者注：</strong>非常怀疑作者在文章开头掉进的大坑就是这个“错误吞噬”。）</p>
<p><em>对于 promises 的误解可能会导致报错信息的丢失。这是一个不少人都会掉进去的大坑。</em></p>
<p>我们看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomeJson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> badJson = <span class="string">"&lt;div&gt;这东西根本不是JSON呀！&lt;/div&gt;"</span>;</span><br><span class="line">    resolve(badJson);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getSomeJson().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'uh oh'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里会发生什么事情呢？我们在 <code>then()</code> 中传递的回调函数期望获得一个有效的 JSON 串，并用原生方法去解析它，因此导致了一个异常。但是我们有一个处理错误的回调函数（也就是 reject 回调），所以是不是米有问题呢？</p>
<p><strong>大错特错。</strong> reject 回调根本不会被调用到！如果你执行上述例子，你不会得到任何的输出。万籁此俱寂，没有错误输出，啥都米有。</p>
<p>为什么会这样呢？因为未经处理的异常在我们 <code>then()</code> 函数传入的回调中发生了，这在我们的实例中被 <code>handle()</code> 捕获到。这导致 <code>handle()</code> 拒绝的 promise 是这个 <code>then()</code> 函数返回的那个 promise，而不是当前的我们准备进行错误处理的 promise ，而当前这个 promise 已经被 resolve 掉了。</p>
<p>如果你想捕获上述的异常，你需要再链一个 <code>then()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getSomeJson().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;).then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"an error occured: "</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在我们能正确的打印错误啦。</p>
<p><em>根据我这么多年使用 promise 的经验，错误吞噬这东西是 promise 最大的坑了（<strong>译者注：</strong>果然是作者掉的那个坑=。=），请阅读下一章节发现更好的解决方案—— <code>done()</code>。</em></p>
<h3 id="救世者-done"><a href="#救世者-done" class="headerlink" title="救世者 done()"></a>救世者 <code>done()</code></h3><p>大多数的 promise 库中都集成了 <code>done()</code> 方法。它与 <code>then()</code> 十分类似，但他避免了上述陷阱。</p>
<p><code>done()</code> 函数可以和 <code>then()</code> 函数一样被调用，其差异之处在于它不会返回一个 promise 对象，且在 <code>done()</code> 中未经处理的异常不会被 promise 实例所捕获。换句话说，当整个 promise 链被完全解决时才会调用 <code>done()</code>。我们的 <code>getSomeJson()</code> 的例子可以使用 <code>done()</code> 来让之变得更加健壮。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    getSomeJson().done(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 当抛出异常时不会被吞没</span></span><br><span class="line">      <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">      <span class="built_in">console</span>.log(obj);</span><br><span class="line">    &#125;);</span><br><span class="line"> <span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>done()<span class="string">` 函数也和 `</span>then()<span class="string">` 一样有一个错误回调， `</span>done(callback, errback)<span class="string">`，当整个 promise 链被执行完成后，你可以保证任何抛出的异常都在错误回调中被捕获。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*`</span>done()<span class="string">` 目前为止还没有加入 promise/A+ 规范，所以某些 promise 库可能并不包含此功能。*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（**译者注：**实际上这里作者所叙述的 `</span>done()<span class="string">` 和我们熟悉的 jQuery 里面实现的 `</span>done()<span class="string">` 并不相同。jQuery 用 Callback 对象实现的 `</span>done()<span class="string">` 方法，只能传递一个成功回调函数，且其返回的不是一个新的 promise 对象，而是当前的 promise 对象。）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Promise 解决程序需要异步调用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在文章的开始我们使用 `</span>setTimeout<span class="string">` 搞了一个毛招，当我们用“状态”这一概念解决掉这个毛招之后，我们就再未曾再见到过 `</span>setTimeout<span class="string">` 了呢。但实际上 Promise/A+ 规范要求 promise 的解决程序必须是异步的。为了符合这个小需求，我们只需简单的将 `</span>handle()<span class="string">` 方法中的大部分实现包裹在 `</span>setTimeout<span class="string">` 中即可。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        deferred = handler;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ... 一切如前</span></span><br><span class="line">      &#125;, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上就是我们所需要做的事情。事实上真正的 promise 库不必非使用 <code>setTimeout</code>。如果 promise 库是基于 NodeJS 的，那可能会用到 <code>process.nextTick</code>；如果基于前端浏览器可能会用到最新的 <code>setImmediate</code> 或是 <a href="https://github.com/YuzuJS/setImmediate" target="_blank" rel="noopener">setImmediate shim</a> （因为迄今为止只有 IE 支持 <code>setImmediate</code>），或者可能是一个异步的函数库，如 Kris Kowal 的 <a href="https://github.com/kriskowal/asap" target="_blank" rel="noopener">asap</a>（此人还写了一个著名的 promise 库 —— <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q</a>）。</p>
<h3 id="为何在规范里要求异步调用？"><a href="#为何在规范里要求异步调用？" class="headerlink" title="为何在规范里要求异步调用？"></a>为何在规范里要求异步调用？</h3><p>这是为了保证一致性和可靠的执行流程，例如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = doAnOperation();</span><br><span class="line">invokeSomething();</span><br><span class="line">promise.then(wrapItAllUp);</span><br><span class="line">invokeSomethingElse();</span><br></pre></td></tr></table></figure>
<p>这里的执行流程会是怎样的呢？根据函数命名我们猜测应该是这样<code>invokeSomething()</code> -&gt; <code>invokeSomethingElse()</code> -&gt; <code>wrapItAllUp</code>。但这其实完全取决于你当前实现的 promise 的解决方式是同步的还是异步的。如果 <code>doAnOperation()</code> 是异步的，那其执行顺序就和我们猜测的一样；如果它是同步执行的，实际的执行顺序就会是这样：<code>invokeSomething()</code> -&gt; <code>wrapItAllUp</code> -&gt; <code>invokeSomethingElse()</code>，这可能就会出现问题。</p>
<p>为了处理这种情况， 即使异步不是必须的，但 <strong>promise 的解决程序也必须是异步的</strong>。这减少了不必要的困扰，也让使用者在使用过程中不必考率代码里的异步实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>能读到这里你也是挺给力的……本文涵盖了规范中所要求的 promise 的核心实现，但大多数的 promise 库都提供了更多的功能，如 <code>all()</code> 、<code>spread()</code> 、<code>race()</code> 、<code>denodeify()</code> 等等。如果想了解 promise 的更多功能，我建议诸位看看 Bluebird 函数库的 <a href="https://github.com/petkaantonov/bluebird/blob/master/API.md" target="_blank" rel="noopener">API</a>。</p>
<p>在我了解了 promise 的运作方式和可能的坑之后，我爱上了 promise =v=。她让我们的代码变得非常整洁和优雅。当然这篇文章仅仅是个开始，对于 promise 而言，能够讨论的东西还有太多太多。</p>
<p>如果你喜欢这篇文章，你可以在我的 <a href="http://twitter.com/cityfortyone" target="_blank" rel="noopener">twitter</a> 上关注我一下，当我有别的更新的时候你也能及时发现~</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://www.promisejs.org/" target="_blank" rel="noopener">promisejs.org</a> 文本中多次提到的 promises 教学</li>
<li><a href="https://github.com/kriskowal/q/blob/v1/design/README.js" target="_blank" rel="noopener">Q  的基本设计原理</a> 形式上和本文差不多的一篇文章，但细节上更加深入。作者就是 Q 之父 Kris Kowal。</li>
<li><a href="https://github.com/domenic/promises-unwrapping/issues/19" target="_blank" rel="noopener">有关 done() 大法好不好的争论</a></li>
<li><a href="http://solutionoptimist.com/2013/12/27/javascript-promise-chains-2/" target="_blank" rel="noopener">扁平化的链式 Promise</a> 作者是 Thomas Burleson，一篇给力的文章探讨 promise 的进阶用法。如果本文主要讲了什么是 promise，那这篇文章就更多的围绕为什么这样实现来展开。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.mattgreer.org/articles/promises-in-wicked-detail/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Promises … In Wicked Detail&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我在 JavaScript 中使用 Promise 已经有一段时间了，目前我已经能高效的使用这一开始让我晕头转向的东西。但真要细说起来，我发现还是不能完全理解它的实现原理，这也正是本文写作的目的所在。如果诸位读者也处在一知半解的状态，那请读完这篇文章，相信你也会像我一样对 Promise 有更好的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/tags/Javascript/"/>
    
      <category term="翻译" scheme="http://malcolmyu.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Promise" scheme="http://malcolmyu.github.io/tags/Promise/"/>
    
  </entry>
  
</feed>
